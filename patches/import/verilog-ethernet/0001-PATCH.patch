From 71ff7514f204a06ed80017e724b32de296b9fb2d Mon Sep 17 00:00:00 2001
From: Dan Petrisko <petrisko@cs.washington.edu>
Date: Fri, 11 Oct 2024 01:01:16 -0700
Subject: [PATCH] PATCH

---
 lib/axis/rtl/axis_adapter.v            |  645 ++++++++++++-------
 lib/axis/rtl/axis_async_fifo.v         | 1056 +++++++++-----------------------
 lib/axis/rtl/axis_async_fifo_adapter.v |  216 +++----
 lib/axis/rtl/axis_fifo.v               |  456 ++++----------
 rtl/axis_gmii_rx.v                     |  116 ++--
 rtl/axis_gmii_tx.v                     |  199 +++---
 rtl/eth_mac_1g.v                       |  533 +---------------
 rtl/eth_mac_1g_rgmii.v                 |  142 +++--
 rtl/eth_mac_1g_rgmii_fifo.v            |  162 +++--
 rtl/lfsr.v                             |  495 +++++----------
 rtl/rgmii_phy_if.v                     |  258 ++++----
 rtl/ssio_ddr_in.v                      |  109 +---
 12 files changed, 1564 insertions(+), 2823 deletions(-)

diff --git a/lib/axis/rtl/axis_adapter.v b/lib/axis/rtl/axis_adapter.v
index 0dedfac..235baf6 100644
--- a/lib/axis/rtl/axis_adapter.v
+++ b/lib/axis/rtl/axis_adapter.v
@@ -1,6 +1,6 @@
 /*
 
-Copyright (c) 2014-2023 Alex Forencich
+Copyright (c) 2014-2018 Alex Forencich
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -24,10 +24,6 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * AXI4-Stream bus width adapter
  */
@@ -39,14 +35,14 @@ module axis_adapter #
     // If disabled, tkeep assumed to be 1'b1
     parameter S_KEEP_ENABLE = (S_DATA_WIDTH>8),
     // tkeep signal width (words per cycle) on input interface
-    parameter S_KEEP_WIDTH = ((S_DATA_WIDTH+7)/8),
+    parameter S_KEEP_WIDTH = (S_DATA_WIDTH/8),
     // Width of output AXI stream interface in bits
     parameter M_DATA_WIDTH = 8,
     // Propagate tkeep signal on output interface
     // If disabled, tkeep assumed to be 1'b1
     parameter M_KEEP_ENABLE = (M_DATA_WIDTH>8),
     // tkeep signal width (words per cycle) on output interface
-    parameter M_KEEP_WIDTH = ((M_DATA_WIDTH+7)/8),
+    parameter M_KEEP_WIDTH = (M_DATA_WIDTH/8),
     // Propagate tid signal
     parameter ID_ENABLE = 0,
     // tid signal width
@@ -90,236 +86,469 @@ module axis_adapter #
 );
 
 // force keep width to 1 when disabled
-localparam S_BYTE_LANES = S_KEEP_ENABLE ? S_KEEP_WIDTH : 1;
-localparam M_BYTE_LANES = M_KEEP_ENABLE ? M_KEEP_WIDTH : 1;
-
-// bus byte sizes (must be identical)
-localparam S_BYTE_SIZE = S_DATA_WIDTH / S_BYTE_LANES;
-localparam M_BYTE_SIZE = M_DATA_WIDTH / M_BYTE_LANES;
+parameter S_KEEP_WIDTH_INT = S_KEEP_ENABLE ? S_KEEP_WIDTH : 1;
+parameter M_KEEP_WIDTH_INT = M_KEEP_ENABLE ? M_KEEP_WIDTH : 1;
+
+// bus word sizes (must be identical)
+parameter S_DATA_WORD_SIZE = S_DATA_WIDTH / S_KEEP_WIDTH_INT;
+parameter M_DATA_WORD_SIZE = M_DATA_WIDTH / M_KEEP_WIDTH_INT;
+// output bus is wider
+parameter EXPAND_BUS = M_KEEP_WIDTH_INT > S_KEEP_WIDTH_INT;
+// total data and keep widths
+parameter DATA_WIDTH = EXPAND_BUS ? M_DATA_WIDTH : S_DATA_WIDTH;
+parameter KEEP_WIDTH = EXPAND_BUS ? M_KEEP_WIDTH_INT : S_KEEP_WIDTH_INT;
+// required number of segments in wider bus
+parameter SEGMENT_COUNT = EXPAND_BUS ? (M_KEEP_WIDTH_INT / S_KEEP_WIDTH_INT) : (S_KEEP_WIDTH_INT / M_KEEP_WIDTH_INT);
+parameter SEGMENT_COUNT_WIDTH = SEGMENT_COUNT == 1 ? 1 : $clog2(SEGMENT_COUNT);
+// data width and keep width per segment
+parameter SEGMENT_DATA_WIDTH = DATA_WIDTH / SEGMENT_COUNT;
+parameter SEGMENT_KEEP_WIDTH = KEEP_WIDTH / SEGMENT_COUNT;
 
 // bus width assertions
 initial begin
-    if (S_BYTE_SIZE * S_BYTE_LANES != S_DATA_WIDTH) begin
-        $error("Error: input data width not evenly divisible (instance %m)");
+    if (S_DATA_WORD_SIZE * S_KEEP_WIDTH_INT != S_DATA_WIDTH) begin
+        $error("Error: input data width not evenly divisble (instance %m)");
         $finish;
     end
 
-    if (M_BYTE_SIZE * M_BYTE_LANES != M_DATA_WIDTH) begin
-        $error("Error: output data width not evenly divisible (instance %m)");
+    if (M_DATA_WORD_SIZE * M_KEEP_WIDTH_INT != M_DATA_WIDTH) begin
+        $error("Error: output data width not evenly divisble (instance %m)");
         $finish;
     end
 
-    if (S_BYTE_SIZE != M_BYTE_SIZE) begin
-        $error("Error: byte size mismatch (instance %m)");
+    if (S_DATA_WORD_SIZE != M_DATA_WORD_SIZE) begin
+        $error("Error: word size mismatch (instance %m)");
         $finish;
     end
 end
 
-generate
-
-if (M_BYTE_LANES == S_BYTE_LANES) begin : bypass
-    // same width; bypass
-
-    assign s_axis_tready = m_axis_tready;
-
-    assign m_axis_tdata  = s_axis_tdata;
-    assign m_axis_tkeep  = M_KEEP_ENABLE ? s_axis_tkeep : {M_KEEP_WIDTH{1'b1}};
-    assign m_axis_tvalid = s_axis_tvalid;
-    assign m_axis_tlast  = s_axis_tlast;
-    assign m_axis_tid    = ID_ENABLE   ? s_axis_tid   : {ID_WIDTH{1'b0}};
-    assign m_axis_tdest  = DEST_ENABLE ? s_axis_tdest : {DEST_WIDTH{1'b0}};
-    assign m_axis_tuser  = USER_ENABLE ? s_axis_tuser : {USER_WIDTH{1'b0}};
-
-end else if (M_BYTE_LANES > S_BYTE_LANES) begin : upsize
-    // output is wider; upsize
-
-    // required number of segments in wider bus
-    localparam SEG_COUNT = M_BYTE_LANES / S_BYTE_LANES;
-    // data width and keep width per segment
-    localparam SEG_DATA_WIDTH = M_DATA_WIDTH / SEG_COUNT;
-    localparam SEG_KEEP_WIDTH = M_BYTE_LANES / SEG_COUNT;
-
-    reg [$clog2(SEG_COUNT)-1:0] seg_reg = 0;
-
-    reg [S_DATA_WIDTH-1:0] s_axis_tdata_reg = {S_DATA_WIDTH{1'b0}};
-    reg [S_KEEP_WIDTH-1:0] s_axis_tkeep_reg = {S_KEEP_WIDTH{1'b0}};
-    reg s_axis_tvalid_reg = 1'b0;
-    reg s_axis_tlast_reg = 1'b0;
-    reg [ID_WIDTH-1:0] s_axis_tid_reg = {ID_WIDTH{1'b0}};
-    reg [DEST_WIDTH-1:0] s_axis_tdest_reg = {DEST_WIDTH{1'b0}};
-    reg [USER_WIDTH-1:0] s_axis_tuser_reg = {USER_WIDTH{1'b0}};
-
-    reg [M_DATA_WIDTH-1:0] m_axis_tdata_reg = {M_DATA_WIDTH{1'b0}};
-    reg [M_KEEP_WIDTH-1:0] m_axis_tkeep_reg = {M_KEEP_WIDTH{1'b0}};
-    reg m_axis_tvalid_reg = 1'b0;
-    reg m_axis_tlast_reg = 1'b0;
-    reg [ID_WIDTH-1:0] m_axis_tid_reg = {ID_WIDTH{1'b0}};
-    reg [DEST_WIDTH-1:0] m_axis_tdest_reg = {DEST_WIDTH{1'b0}};
-    reg [USER_WIDTH-1:0] m_axis_tuser_reg = {USER_WIDTH{1'b0}};
-
-    assign s_axis_tready = !s_axis_tvalid_reg;
-
-    assign m_axis_tdata  = m_axis_tdata_reg;
-    assign m_axis_tkeep  = M_KEEP_ENABLE ? m_axis_tkeep_reg : {M_KEEP_WIDTH{1'b1}};
-    assign m_axis_tvalid = m_axis_tvalid_reg;
-    assign m_axis_tlast  = m_axis_tlast_reg;
-    assign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};
-    assign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};
-    assign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};
-
-    always @(posedge clk) begin
-        m_axis_tvalid_reg <= m_axis_tvalid_reg && !m_axis_tready;
-
-        if (!m_axis_tvalid_reg || m_axis_tready) begin
-            // output register empty
-
-            if (seg_reg == 0) begin
-                m_axis_tdata_reg[seg_reg*SEG_DATA_WIDTH +: SEG_DATA_WIDTH] <= s_axis_tvalid_reg ? s_axis_tdata_reg : s_axis_tdata;
-                m_axis_tkeep_reg <= s_axis_tvalid_reg ? s_axis_tkeep_reg : s_axis_tkeep;
-            end else begin
-                m_axis_tdata_reg[seg_reg*SEG_DATA_WIDTH +: SEG_DATA_WIDTH] <= s_axis_tdata;
-                m_axis_tkeep_reg[seg_reg*SEG_KEEP_WIDTH +: SEG_KEEP_WIDTH] <= s_axis_tkeep;
-            end
-            m_axis_tlast_reg <= s_axis_tvalid_reg ? s_axis_tlast_reg : s_axis_tlast;
-            m_axis_tid_reg <= s_axis_tvalid_reg ? s_axis_tid_reg : s_axis_tid;
-            m_axis_tdest_reg <= s_axis_tvalid_reg ? s_axis_tdest_reg : s_axis_tdest;
-            m_axis_tuser_reg <= s_axis_tvalid_reg ? s_axis_tuser_reg : s_axis_tuser;
-
-            if (s_axis_tvalid_reg) begin
-                // consume data from buffer
-                s_axis_tvalid_reg <= 1'b0;
-
-                if (s_axis_tlast_reg || seg_reg == SEG_COUNT-1) begin
-                    seg_reg <= 0;
-                    m_axis_tvalid_reg <= 1'b1;
+// state register
+localparam [2:0]
+    STATE_IDLE = 3'd0,
+    STATE_TRANSFER_IN = 3'd1,
+    STATE_TRANSFER_OUT = 3'd2;
+
+reg [2:0] state_reg, state_next;
+
+reg [SEGMENT_COUNT_WIDTH-1:0] segment_count_reg, segment_count_next;
+
+reg last_segment;
+
+reg [DATA_WIDTH-1:0] temp_tdata_reg, temp_tdata_next;
+reg [KEEP_WIDTH-1:0] temp_tkeep_reg, temp_tkeep_next;
+reg                  temp_tlast_reg, temp_tlast_next;
+reg [ID_WIDTH-1:0]   temp_tid_reg, temp_tid_next;
+reg [DEST_WIDTH-1:0] temp_tdest_reg, temp_tdest_next;
+reg [USER_WIDTH-1:0] temp_tuser_reg, temp_tuser_next;
+
+// internal datapath
+reg  [M_DATA_WIDTH-1:0] m_axis_tdata_int;
+reg  [M_KEEP_WIDTH-1:0] m_axis_tkeep_int;
+reg                     m_axis_tvalid_int;
+reg                     m_axis_tready_int_reg;
+reg                     m_axis_tlast_int;
+reg  [ID_WIDTH-1:0]     m_axis_tid_int;
+reg  [DEST_WIDTH-1:0]   m_axis_tdest_int;
+reg  [USER_WIDTH-1:0]   m_axis_tuser_int;
+wire                    m_axis_tready_int_early;
+
+reg s_axis_tready_reg, s_axis_tready_next;
+
+assign s_axis_tready = s_axis_tready_reg;
+
+always @* begin
+    state_next = STATE_IDLE;
+
+    segment_count_next = segment_count_reg;
+
+    last_segment = 0;
+
+    temp_tdata_next = temp_tdata_reg;
+    temp_tkeep_next = temp_tkeep_reg;
+    temp_tlast_next = temp_tlast_reg;
+    temp_tid_next   = temp_tid_reg;
+    temp_tdest_next = temp_tdest_reg;
+    temp_tuser_next = temp_tuser_reg;
+
+    if (EXPAND_BUS) begin
+        m_axis_tdata_int  = temp_tdata_reg;
+        m_axis_tkeep_int  = temp_tkeep_reg;
+        m_axis_tlast_int  = temp_tlast_reg;
+    end else begin
+        m_axis_tdata_int  = {M_DATA_WIDTH{1'b0}};
+        m_axis_tkeep_int  = {M_KEEP_WIDTH{1'b0}};
+        m_axis_tlast_int  = 1'b0;
+    end
+    m_axis_tvalid_int = 1'b0;
+    m_axis_tid_int    = temp_tid_reg;
+    m_axis_tdest_int  = temp_tdest_reg;
+    m_axis_tuser_int  = temp_tuser_reg;
+
+    s_axis_tready_next = 1'b0;
+
+    case (state_reg)
+        STATE_IDLE: begin
+            // idle state - no data in registers
+            if (SEGMENT_COUNT == 1) begin
+                // output and input same width - just act like a register
+
+                // accept data next cycle if output register ready next cycle
+                s_axis_tready_next = m_axis_tready_int_early;
+
+                // transfer through
+                m_axis_tdata_int  = s_axis_tdata;
+                m_axis_tkeep_int  = S_KEEP_ENABLE ? s_axis_tkeep : 1'b1;
+                m_axis_tvalid_int = s_axis_tvalid;
+                m_axis_tlast_int  = s_axis_tlast;
+                m_axis_tid_int    = s_axis_tid;
+                m_axis_tdest_int  = s_axis_tdest;
+                m_axis_tuser_int  = s_axis_tuser;
+
+                state_next = STATE_IDLE;
+            end else if (EXPAND_BUS) begin
+                // output bus is wider
+
+                // accept new data
+                s_axis_tready_next = 1'b1;
+
+                if (s_axis_tready && s_axis_tvalid) begin
+                    // word transfer in - store it in data register
+
+                    // pass complete input word, zero-extended to temp register
+                    temp_tdata_next = s_axis_tdata;
+                    temp_tkeep_next = S_KEEP_ENABLE ? s_axis_tkeep : 1'b1;
+                    temp_tlast_next = s_axis_tlast;
+                    temp_tid_next   = s_axis_tid;
+                    temp_tdest_next = s_axis_tdest;
+                    temp_tuser_next = s_axis_tuser;
+
+                    // first input segment complete
+                    segment_count_next = 1;
+
+                    if (s_axis_tlast) begin
+                        // got last signal on first segment, so output it
+                        s_axis_tready_next = 1'b0;
+                        state_next = STATE_TRANSFER_OUT;
+                    end else begin
+                        // otherwise, transfer in the rest of the words
+                        s_axis_tready_next = 1'b1;
+                        state_next = STATE_TRANSFER_IN;
+                    end
                 end else begin
-                    seg_reg <= seg_reg + 1;
+                    state_next = STATE_IDLE;
                 end
-            end else if (s_axis_tvalid) begin
-                // data direct from input
-                if (s_axis_tlast || seg_reg == SEG_COUNT-1) begin
-                    seg_reg <= 0;
-                    m_axis_tvalid_reg <= 1'b1;
+            end else begin
+                // output bus is narrower
+
+                // accept new data
+                s_axis_tready_next = 1'b1;
+
+                if (s_axis_tready && s_axis_tvalid) begin
+                    // word transfer in - store it in data register
+                    segment_count_next = 0;
+
+                    // is this the last segment?
+                    if (SEGMENT_COUNT == 1) begin
+                        // last segment by counter value
+                        last_segment = 1'b1;
+                    end else if (S_KEEP_ENABLE && s_axis_tkeep[SEGMENT_KEEP_WIDTH-1:0] != {SEGMENT_KEEP_WIDTH{1'b1}}) begin
+                        // last segment by tkeep fall in current segment
+                        last_segment = 1'b1;
+                    end else if (S_KEEP_ENABLE && s_axis_tkeep[(SEGMENT_KEEP_WIDTH*2)-1:SEGMENT_KEEP_WIDTH] == {SEGMENT_KEEP_WIDTH{1'b0}}) begin
+                        // last segment by tkeep fall at end of current segment
+                        last_segment = 1'b1;
+                    end else begin
+                        last_segment = 1'b0;
+                    end
+
+                    // pass complete input word, zero-extended to temp register
+                    temp_tdata_next = s_axis_tdata;
+                    temp_tkeep_next = S_KEEP_ENABLE ? s_axis_tkeep : 1'b1;
+                    temp_tlast_next = s_axis_tlast;
+                    temp_tid_next   = s_axis_tid;
+                    temp_tdest_next = s_axis_tdest;
+                    temp_tuser_next = s_axis_tuser;
+
+                    // short-circuit and get first word out the door
+                    m_axis_tdata_int  = s_axis_tdata[SEGMENT_DATA_WIDTH-1:0];
+                    m_axis_tkeep_int  = s_axis_tkeep[SEGMENT_KEEP_WIDTH-1:0];
+                    m_axis_tvalid_int = 1'b1;
+                    m_axis_tlast_int  = s_axis_tlast & last_segment;
+                    m_axis_tid_int    = s_axis_tid;
+                    m_axis_tdest_int  = s_axis_tdest;
+                    m_axis_tuser_int  = s_axis_tuser;
+
+                    if (m_axis_tready_int_reg) begin
+                        // if output register is ready for first word, then move on to the next one
+                        segment_count_next = 1;
+                    end
+
+                    if (!last_segment || !m_axis_tready_int_reg) begin
+                        // continue outputting words
+                        s_axis_tready_next = 1'b0;
+                        state_next = STATE_TRANSFER_OUT;
+                    end else begin
+                        state_next = STATE_IDLE;
+                    end
                 end else begin
-                    seg_reg <= seg_reg + 1;
+                    state_next = STATE_IDLE;
                 end
             end
-        end else if (s_axis_tvalid && s_axis_tready) begin
-            // store input data in skid buffer
-            s_axis_tdata_reg <= s_axis_tdata;
-            s_axis_tkeep_reg <= s_axis_tkeep;
-            s_axis_tvalid_reg <= 1'b1;
-            s_axis_tlast_reg <= s_axis_tlast;
-            s_axis_tid_reg <= s_axis_tid;
-            s_axis_tdest_reg <= s_axis_tdest;
-            s_axis_tuser_reg <= s_axis_tuser;
         end
-
-        if (rst) begin
-            seg_reg <= 0;
-            s_axis_tvalid_reg <= 1'b0;
-            m_axis_tvalid_reg <= 1'b0;
+        STATE_TRANSFER_IN: begin
+            // transfer word to temp registers
+            // only used when output is wider
+
+            // accept new data
+            s_axis_tready_next = 1'b1;
+
+            if (s_axis_tready && s_axis_tvalid) begin
+                // word transfer in - store in data register
+
+                temp_tdata_next[segment_count_reg*SEGMENT_DATA_WIDTH +: SEGMENT_DATA_WIDTH] = s_axis_tdata;
+                temp_tkeep_next[segment_count_reg*SEGMENT_KEEP_WIDTH +: SEGMENT_KEEP_WIDTH] = S_KEEP_ENABLE ? s_axis_tkeep : 1'b1;
+                temp_tlast_next = s_axis_tlast;
+                temp_tid_next   = s_axis_tid;
+                temp_tdest_next = s_axis_tdest;
+                temp_tuser_next = s_axis_tuser;
+
+                segment_count_next = segment_count_reg + 1;
+
+                if ((segment_count_reg == SEGMENT_COUNT-1) || s_axis_tlast) begin
+                    // terminated by counter or tlast signal, output complete word
+                    // read input word next cycle if output will be ready
+                    s_axis_tready_next = m_axis_tready_int_early;
+                    state_next = STATE_TRANSFER_OUT;
+                end else begin
+                    // more words to read
+                    s_axis_tready_next = 1'b1;
+                    state_next = STATE_TRANSFER_IN;
+                end
+            end else begin
+                state_next = STATE_TRANSFER_IN;
+            end
         end
-    end
-
-end else begin : downsize
-    // output is narrower; downsize
-
-    // required number of segments in wider bus
-    localparam SEG_COUNT = S_BYTE_LANES / M_BYTE_LANES;
-    // data width and keep width per segment
-    localparam SEG_DATA_WIDTH = S_DATA_WIDTH / SEG_COUNT;
-    localparam SEG_KEEP_WIDTH = S_BYTE_LANES / SEG_COUNT;
-
-    reg [S_DATA_WIDTH-1:0] s_axis_tdata_reg = {S_DATA_WIDTH{1'b0}};
-    reg [S_KEEP_WIDTH-1:0] s_axis_tkeep_reg = {S_KEEP_WIDTH{1'b0}};
-    reg s_axis_tvalid_reg = 1'b0;
-    reg s_axis_tlast_reg = 1'b0;
-    reg [ID_WIDTH-1:0] s_axis_tid_reg = {ID_WIDTH{1'b0}};
-    reg [DEST_WIDTH-1:0] s_axis_tdest_reg = {DEST_WIDTH{1'b0}};
-    reg [USER_WIDTH-1:0] s_axis_tuser_reg = {USER_WIDTH{1'b0}};
-
-    reg [M_DATA_WIDTH-1:0] m_axis_tdata_reg = {M_DATA_WIDTH{1'b0}};
-    reg [M_KEEP_WIDTH-1:0] m_axis_tkeep_reg = {M_KEEP_WIDTH{1'b0}};
-    reg m_axis_tvalid_reg = 1'b0;
-    reg m_axis_tlast_reg = 1'b0;
-    reg [ID_WIDTH-1:0] m_axis_tid_reg = {ID_WIDTH{1'b0}};
-    reg [DEST_WIDTH-1:0] m_axis_tdest_reg = {DEST_WIDTH{1'b0}};
-    reg [USER_WIDTH-1:0] m_axis_tuser_reg = {USER_WIDTH{1'b0}};
-
-    assign s_axis_tready = !s_axis_tvalid_reg;
-
-    assign m_axis_tdata  = m_axis_tdata_reg;
-    assign m_axis_tkeep  = M_KEEP_ENABLE ? m_axis_tkeep_reg : {M_KEEP_WIDTH{1'b1}};
-    assign m_axis_tvalid = m_axis_tvalid_reg;
-    assign m_axis_tlast  = m_axis_tlast_reg;
-    assign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};
-    assign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};
-    assign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};
-
-    always @(posedge clk) begin
-        m_axis_tvalid_reg <= m_axis_tvalid_reg && !m_axis_tready;
-
-        if (!m_axis_tvalid_reg || m_axis_tready) begin
-            // output register empty
-
-            m_axis_tdata_reg <= s_axis_tvalid_reg ? s_axis_tdata_reg : s_axis_tdata;
-            m_axis_tkeep_reg <= s_axis_tvalid_reg ? s_axis_tkeep_reg : s_axis_tkeep;
-            m_axis_tlast_reg <= 1'b0;
-            m_axis_tid_reg <= s_axis_tvalid_reg ? s_axis_tid_reg : s_axis_tid;
-            m_axis_tdest_reg <= s_axis_tvalid_reg ? s_axis_tdest_reg : s_axis_tdest;
-            m_axis_tuser_reg <= s_axis_tvalid_reg ? s_axis_tuser_reg : s_axis_tuser;
-
-            if (s_axis_tvalid_reg) begin
-                // buffer has data; shift out from buffer
-                s_axis_tdata_reg <= s_axis_tdata_reg >> SEG_DATA_WIDTH;
-                s_axis_tkeep_reg <= s_axis_tkeep_reg >> SEG_KEEP_WIDTH;
-
-                m_axis_tvalid_reg <= 1'b1;
-
-                if ((s_axis_tkeep_reg >> SEG_KEEP_WIDTH) == 0) begin
-                    s_axis_tvalid_reg <= 1'b0;
-                    m_axis_tlast_reg <= s_axis_tlast_reg;
+        STATE_TRANSFER_OUT: begin
+            // transfer word to output registers
+
+            if (EXPAND_BUS) begin
+                // output bus is wider
+
+                // do not accept new data
+                s_axis_tready_next = 1'b0;
+
+                // single-cycle output of entire stored word (output wider)
+                m_axis_tdata_int  = temp_tdata_reg;
+                m_axis_tkeep_int  = temp_tkeep_reg;
+                m_axis_tvalid_int = 1'b1;
+                m_axis_tlast_int  = temp_tlast_reg;
+                m_axis_tid_int    = temp_tid_reg;
+                m_axis_tdest_int  = temp_tdest_reg;
+                m_axis_tuser_int  = temp_tuser_reg;
+
+                if (m_axis_tready_int_reg) begin
+                    // word transfer out
+
+                    if (s_axis_tready && s_axis_tvalid) begin
+                        // word transfer in
+
+                        // pass complete input word, zero-extended to temp register
+                        temp_tdata_next = s_axis_tdata;
+                        temp_tkeep_next = S_KEEP_ENABLE ? s_axis_tkeep : 1'b1;
+                        temp_tlast_next = s_axis_tlast;
+                        temp_tid_next   = s_axis_tid;
+                        temp_tdest_next = s_axis_tdest;
+                        temp_tuser_next = s_axis_tuser;
+
+                        // first input segment complete
+                        segment_count_next = 1;
+
+                        if (s_axis_tlast) begin
+                            // got last signal on first segment, so output it
+                            s_axis_tready_next = 1'b0;
+                            state_next = STATE_TRANSFER_OUT;
+                        end else begin
+                            // otherwise, transfer in the rest of the words
+                            s_axis_tready_next = 1'b1;
+                            state_next = STATE_TRANSFER_IN;
+                        end
+                    end else begin
+                        s_axis_tready_next = 1'b1;
+                        state_next = STATE_IDLE;
+                    end
+                end else begin
+                    state_next = STATE_TRANSFER_OUT;
+                end
+            end else begin
+                // output bus is narrower
+
+                // do not accept new data
+                s_axis_tready_next = 1'b0;
+
+                // is this the last segment?
+                if (segment_count_reg == SEGMENT_COUNT-1) begin
+                    // last segment by counter value
+                    last_segment = 1'b1;
+                end else if (temp_tkeep_reg[segment_count_reg*SEGMENT_KEEP_WIDTH +: SEGMENT_KEEP_WIDTH] != {SEGMENT_KEEP_WIDTH{1'b1}}) begin
+                    // last segment by tkeep fall in current segment
+                    last_segment = 1'b1;
+                end else if (temp_tkeep_reg[(segment_count_reg+1)*SEGMENT_KEEP_WIDTH +: SEGMENT_KEEP_WIDTH] == {SEGMENT_KEEP_WIDTH{1'b0}}) begin
+                    // last segment by tkeep fall at end of current segment
+                    last_segment = 1'b1;
+                end else begin
+                    last_segment = 1'b0;
                 end
-            end else if (s_axis_tvalid && s_axis_tready) begin
-                // buffer is empty; store from input
-                s_axis_tdata_reg <= s_axis_tdata >> SEG_DATA_WIDTH;
-                s_axis_tkeep_reg <= s_axis_tkeep >> SEG_KEEP_WIDTH;
-                s_axis_tlast_reg <= s_axis_tlast;
-                s_axis_tid_reg <= s_axis_tid;
-                s_axis_tdest_reg <= s_axis_tdest;
-                s_axis_tuser_reg <= s_axis_tuser;
-
-                m_axis_tvalid_reg <= 1'b1;
-
-                if ((s_axis_tkeep >> SEG_KEEP_WIDTH) == 0) begin
-                    s_axis_tvalid_reg <= 1'b0;
-                    m_axis_tlast_reg <= s_axis_tlast;
+
+                // output current part of stored word (output narrower)
+                m_axis_tdata_int  = temp_tdata_reg[segment_count_reg*SEGMENT_DATA_WIDTH +: SEGMENT_DATA_WIDTH];
+                m_axis_tkeep_int  = temp_tkeep_reg[segment_count_reg*SEGMENT_KEEP_WIDTH +: SEGMENT_KEEP_WIDTH];
+                m_axis_tvalid_int = 1'b1;
+                m_axis_tlast_int  = temp_tlast_reg && last_segment;
+                m_axis_tid_int    = temp_tid_reg;
+                m_axis_tdest_int  = temp_tdest_reg;
+                m_axis_tuser_int  = temp_tuser_reg;
+
+                if (m_axis_tready_int_reg) begin
+                    // word transfer out
+
+                    segment_count_next = segment_count_reg + 1;
+
+                    if (last_segment) begin
+                        // terminated by counter or tlast signal
+
+                        s_axis_tready_next = 1'b1;
+                        state_next = STATE_IDLE;
+                    end else begin
+                        // more words to write
+                        state_next = STATE_TRANSFER_OUT;
+                    end
                 end else begin
-                    s_axis_tvalid_reg <= 1'b1;
+                    state_next = STATE_TRANSFER_OUT;
                 end
             end
-        end else if (s_axis_tvalid && s_axis_tready) begin
-            // store input data
-            s_axis_tdata_reg <= s_axis_tdata;
-            s_axis_tkeep_reg <= s_axis_tkeep;
-            s_axis_tvalid_reg <= 1'b1;
-            s_axis_tlast_reg <= s_axis_tlast;
-            s_axis_tid_reg <= s_axis_tid;
-            s_axis_tdest_reg <= s_axis_tdest;
-            s_axis_tuser_reg <= s_axis_tuser;
         end
+    endcase
+end
 
-        if (rst) begin
-            s_axis_tvalid_reg <= 1'b0;
-            m_axis_tvalid_reg <= 1'b0;
-        end
+always @(posedge clk) begin
+    if (rst) begin
+        segment_count_reg <= '0;
+
+        state_reg <= STATE_IDLE;
+        s_axis_tready_reg <= 1'b0;
+    end else begin
+        state_reg <= state_next;
+
+        s_axis_tready_reg <= s_axis_tready_next;
     end
 
+    segment_count_reg <= segment_count_next;
+
+    temp_tdata_reg <= temp_tdata_next;
+    temp_tkeep_reg <= temp_tkeep_next;
+    temp_tlast_reg <= temp_tlast_next;
+    temp_tid_reg   <= temp_tid_next;
+    temp_tdest_reg <= temp_tdest_next;
+    temp_tuser_reg <= temp_tuser_next;
 end
 
-endgenerate
+// output datapath logic
+reg [M_DATA_WIDTH-1:0] m_axis_tdata_reg;
+reg [M_KEEP_WIDTH-1:0] m_axis_tkeep_reg;
+reg                    m_axis_tvalid_reg, m_axis_tvalid_next;
+reg                    m_axis_tlast_reg;
+reg [ID_WIDTH-1:0]     m_axis_tid_reg;
+reg [DEST_WIDTH-1:0]   m_axis_tdest_reg;
+reg [USER_WIDTH-1:0]   m_axis_tuser_reg;
+
+reg [M_DATA_WIDTH-1:0] temp_m_axis_tdata_reg;
+reg [M_KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg;
+reg                    temp_m_axis_tvalid_reg, temp_m_axis_tvalid_next;
+reg                    temp_m_axis_tlast_reg;
+reg [ID_WIDTH-1:0]     temp_m_axis_tid_reg;
+reg [DEST_WIDTH-1:0]   temp_m_axis_tdest_reg;
+reg [USER_WIDTH-1:0]   temp_m_axis_tuser_reg;
+
+// datapath control
+reg store_axis_int_to_output;
+reg store_axis_int_to_temp;
+reg store_axis_temp_to_output;
+
+assign m_axis_tdata  = m_axis_tdata_reg;
+assign m_axis_tkeep  = M_KEEP_ENABLE ? m_axis_tkeep_reg : {M_KEEP_WIDTH{1'b1}};
+assign m_axis_tvalid = m_axis_tvalid_reg;
+assign m_axis_tlast  = m_axis_tlast_reg;
+assign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};
+assign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};
+assign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};
+
+// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)
+assign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));
+
+always @* begin
+    // transfer sink ready state to source
+    m_axis_tvalid_next = m_axis_tvalid_reg;
+    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;
+
+    store_axis_int_to_output = 1'b0;
+    store_axis_int_to_temp = 1'b0;
+    store_axis_temp_to_output = 1'b0;
+
+    if (m_axis_tready_int_reg) begin
+        // input is ready
+        if (m_axis_tready || !m_axis_tvalid_reg) begin
+            // output is ready or currently not valid, transfer data to output
+            m_axis_tvalid_next = m_axis_tvalid_int;
+            store_axis_int_to_output = 1'b1;
+        end else begin
+            // output is not ready, store input in temp
+            temp_m_axis_tvalid_next = m_axis_tvalid_int;
+            store_axis_int_to_temp = 1'b1;
+        end
+    end else if (m_axis_tready) begin
+        // input is not ready, but output is ready
+        m_axis_tvalid_next = temp_m_axis_tvalid_reg;
+        temp_m_axis_tvalid_next = 1'b0;
+        store_axis_temp_to_output = 1'b1;
+    end
+end
 
-endmodule
+always @(posedge clk) begin
+    if (rst) begin
+        m_axis_tvalid_reg <= 1'b0;
+        m_axis_tready_int_reg <= 1'b0;
+        temp_m_axis_tvalid_reg <= 1'b0;
+    end else begin
+        m_axis_tvalid_reg <= m_axis_tvalid_next;
+        m_axis_tready_int_reg <= m_axis_tready_int_early;
+        temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;
+    end
+
+    // datapath
+    if (store_axis_int_to_output) begin
+        m_axis_tdata_reg <= m_axis_tdata_int;
+        m_axis_tkeep_reg <= m_axis_tkeep_int;
+        m_axis_tlast_reg <= m_axis_tlast_int;
+        m_axis_tid_reg   <= m_axis_tid_int;
+        m_axis_tdest_reg <= m_axis_tdest_int;
+        m_axis_tuser_reg <= m_axis_tuser_int;
+    end else if (store_axis_temp_to_output) begin
+        m_axis_tdata_reg <= temp_m_axis_tdata_reg;
+        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;
+        m_axis_tlast_reg <= temp_m_axis_tlast_reg;
+        m_axis_tid_reg   <= temp_m_axis_tid_reg;
+        m_axis_tdest_reg <= temp_m_axis_tdest_reg;
+        m_axis_tuser_reg <= temp_m_axis_tuser_reg;
+    end
 
-`resetall
+    if (store_axis_int_to_temp) begin
+        temp_m_axis_tdata_reg <= m_axis_tdata_int;
+        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;
+        temp_m_axis_tlast_reg <= m_axis_tlast_int;
+        temp_m_axis_tid_reg   <= m_axis_tid_int;
+        temp_m_axis_tdest_reg <= m_axis_tdest_int;
+        temp_m_axis_tuser_reg <= m_axis_tuser_int;
+    end
+end
+
+endmodule
diff --git a/lib/axis/rtl/axis_async_fifo.v b/lib/axis/rtl/axis_async_fifo.v
index b73ae6c..51aef89 100644
--- a/lib/axis/rtl/axis_async_fifo.v
+++ b/lib/axis/rtl/axis_async_fifo.v
@@ -1,6 +1,6 @@
 /*
 
-Copyright (c) 2014-2023 Alex Forencich
+Copyright (c) 2014-2021 Alex Forencich
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -24,10 +24,6 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * AXI4-Stream asynchronous FIFO
  */
@@ -43,7 +39,7 @@ module axis_async_fifo #
     // If disabled, tkeep assumed to be 1'b1
     parameter KEEP_ENABLE = (DATA_WIDTH>8),
     // tkeep signal width (words per cycle)
-    parameter KEEP_WIDTH = ((DATA_WIDTH+7)/8),
+    parameter KEEP_WIDTH = (DATA_WIDTH/8),
     // Propagate tlast signal
     parameter LAST_ENABLE = 1,
     // Propagate tid signal
@@ -58,11 +54,8 @@ module axis_async_fifo #
     parameter USER_ENABLE = 1,
     // tuser signal width
     parameter USER_WIDTH = 1,
-    // number of RAM pipeline registers
-    parameter RAM_PIPELINE = 1,
-    // use output FIFO
-    // When set, the RAM read enable and pipeline clock enables are removed
-    parameter OUTPUT_FIFO_ENABLE = 0,
+    // number of output pipeline registers
+    parameter PIPELINE_OUTPUT = 2,
     // Frame FIFO mode - operate on frames instead of cycles
     // When set, m_axis_tvalid will not be deasserted within a frame
     // Requires LAST_ENABLE set
@@ -81,14 +74,9 @@ module axis_async_fifo #
     // When set, s_axis_tready is always asserted
     // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set
     parameter DROP_WHEN_FULL = 0,
-    // Mark incoming frames as bad frames when full
-    // When set, s_axis_tready is always asserted
-    // Requires FRAME_FIFO to be clear
-    parameter MARK_WHEN_FULL = 0,
-    // Enable pause request input
-    parameter PAUSE_ENABLE = 0,
-    // Pause between frames
-    parameter FRAME_PAUSE = FRAME_FIFO
+    // If 1, put a bsg_async_fifo at input side
+    // If 0, put a bsg_async_fifo at output side
+    parameter upstream_async_fifo_p
 )
 (
     /*
@@ -119,71 +107,17 @@ module axis_async_fifo #
     output wire [DEST_WIDTH-1:0]  m_axis_tdest,
     output wire [USER_WIDTH-1:0]  m_axis_tuser,
 
-    /*
-     * Pause
-     */
-    input  wire                   s_pause_req,
-    output wire                   s_pause_ack,
-    input  wire                   m_pause_req,
-    output wire                   m_pause_ack,
-
     /*
      * Status
      */
-    output wire [$clog2(DEPTH):0] s_status_depth,
-    output wire [$clog2(DEPTH):0] s_status_depth_commit,
     output wire                   s_status_overflow,
     output wire                   s_status_bad_frame,
     output wire                   s_status_good_frame,
-    output wire [$clog2(DEPTH):0] m_status_depth,
-    output wire [$clog2(DEPTH):0] m_status_depth_commit,
     output wire                   m_status_overflow,
     output wire                   m_status_bad_frame,
     output wire                   m_status_good_frame
 );
 
-parameter ADDR_WIDTH = (KEEP_ENABLE && KEEP_WIDTH > 1) ? $clog2(DEPTH/KEEP_WIDTH) : $clog2(DEPTH);
-
-parameter OUTPUT_FIFO_ADDR_WIDTH = RAM_PIPELINE < 2 ? 3 : $clog2(RAM_PIPELINE*2+7);
-
-// check configuration
-initial begin
-    if (FRAME_FIFO && !LAST_ENABLE) begin
-        $error("Error: FRAME_FIFO set requires LAST_ENABLE set (instance %m)");
-        $finish;
-    end
-
-    if (DROP_OVERSIZE_FRAME && !FRAME_FIFO) begin
-        $error("Error: DROP_OVERSIZE_FRAME set requires FRAME_FIFO set (instance %m)");
-        $finish;
-    end
-
-    if (DROP_BAD_FRAME && !(FRAME_FIFO && DROP_OVERSIZE_FRAME)) begin
-        $error("Error: DROP_BAD_FRAME set requires FRAME_FIFO and DROP_OVERSIZE_FRAME set (instance %m)");
-        $finish;
-    end
-
-    if (DROP_WHEN_FULL && !(FRAME_FIFO && DROP_OVERSIZE_FRAME)) begin
-        $error("Error: DROP_WHEN_FULL set requires FRAME_FIFO and DROP_OVERSIZE_FRAME set (instance %m)");
-        $finish;
-    end
-
-    if ((DROP_BAD_FRAME || MARK_WHEN_FULL) && (USER_BAD_FRAME_MASK & {USER_WIDTH{1'b1}}) == 0) begin
-        $error("Error: Invalid USER_BAD_FRAME_MASK value (instance %m)");
-        $finish;
-    end
-
-    if (MARK_WHEN_FULL && FRAME_FIFO) begin
-        $error("Error: MARK_WHEN_FULL is not compatible with FRAME_FIFO (instance %m)");
-        $finish;
-    end
-
-    if (MARK_WHEN_FULL && !LAST_ENABLE) begin
-        $error("Error: MARK_WHEN_FULL set requires LAST_ENABLE set (instance %m)");
-        $finish;
-    end
-end
-
 localparam KEEP_OFFSET = DATA_WIDTH;
 localparam LAST_OFFSET = KEEP_OFFSET + (KEEP_ENABLE ? KEEP_WIDTH : 0);
 localparam ID_OFFSET   = LAST_OFFSET + (LAST_ENABLE ? 1          : 0);
@@ -191,720 +125,276 @@ localparam DEST_OFFSET = ID_OFFSET   + (ID_ENABLE   ? ID_WIDTH   : 0);
 localparam USER_OFFSET = DEST_OFFSET + (DEST_ENABLE ? DEST_WIDTH : 0);
 localparam WIDTH       = USER_OFFSET + (USER_ENABLE ? USER_WIDTH : 0);
 
-function [ADDR_WIDTH:0] bin2gray(input [ADDR_WIDTH:0] b);
-    bin2gray = b ^ (b >> 1);
-endfunction
-
-function [ADDR_WIDTH:0] gray2bin(input [ADDR_WIDTH:0] g);
-    integer i;
-    for (i = 0; i <= ADDR_WIDTH; i = i + 1) begin
-        gray2bin[i] = ^(g >> i);
-    end
-endfunction
-
-reg [ADDR_WIDTH:0] wr_ptr_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] wr_ptr_commit_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] wr_ptr_gray_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] wr_ptr_sync_commit_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] rd_ptr_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] rd_ptr_gray_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] wr_ptr_conv_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] rd_ptr_conv_reg = {ADDR_WIDTH+1{1'b0}};
-
-reg [ADDR_WIDTH:0] wr_ptr_temp;
-reg [ADDR_WIDTH:0] rd_ptr_temp;
-
-(* SHREG_EXTRACT = "NO" *)
-reg [ADDR_WIDTH:0] wr_ptr_gray_sync1_reg = {ADDR_WIDTH+1{1'b0}};
-(* SHREG_EXTRACT = "NO" *)
-reg [ADDR_WIDTH:0] wr_ptr_gray_sync2_reg = {ADDR_WIDTH+1{1'b0}};
-(* SHREG_EXTRACT = "NO" *)
-reg [ADDR_WIDTH:0] wr_ptr_commit_sync_reg = {ADDR_WIDTH+1{1'b0}};
-(* SHREG_EXTRACT = "NO" *)
-reg [ADDR_WIDTH:0] rd_ptr_gray_sync1_reg = {ADDR_WIDTH+1{1'b0}};
-(* SHREG_EXTRACT = "NO" *)
-reg [ADDR_WIDTH:0] rd_ptr_gray_sync2_reg = {ADDR_WIDTH+1{1'b0}};
-
-reg wr_ptr_update_valid_reg = 1'b0;
-reg wr_ptr_update_reg = 1'b0;
-(* SHREG_EXTRACT = "NO" *)
-reg wr_ptr_update_sync1_reg = 1'b0;
-(* SHREG_EXTRACT = "NO" *)
-reg wr_ptr_update_sync2_reg = 1'b0;
-(* SHREG_EXTRACT = "NO" *)
-reg wr_ptr_update_sync3_reg = 1'b0;
-(* SHREG_EXTRACT = "NO" *)
-reg wr_ptr_update_ack_sync1_reg = 1'b0;
-(* SHREG_EXTRACT = "NO" *)
-reg wr_ptr_update_ack_sync2_reg = 1'b0;
-
-(* SHREG_EXTRACT = "NO" *)
-reg s_rst_sync1_reg = 1'b1;
-(* SHREG_EXTRACT = "NO" *)
-reg s_rst_sync2_reg = 1'b1;
-(* SHREG_EXTRACT = "NO" *)
-reg s_rst_sync3_reg = 1'b1;
-(* SHREG_EXTRACT = "NO" *)
-reg m_rst_sync1_reg = 1'b1;
-(* SHREG_EXTRACT = "NO" *)
-reg m_rst_sync2_reg = 1'b1;
-(* SHREG_EXTRACT = "NO" *)
-reg m_rst_sync3_reg = 1'b1;
-
-(* ramstyle = "no_rw_check" *)
-reg [WIDTH-1:0] mem[(2**ADDR_WIDTH)-1:0];
-reg mem_read_data_valid_reg = 1'b0;
-
-(* shreg_extract = "no" *)
-reg [WIDTH-1:0] m_axis_pipe_reg[RAM_PIPELINE+1-1:0];
-reg [RAM_PIPELINE+1-1:0] m_axis_tvalid_pipe_reg = 0;
-
-// full when first TWO MSBs do NOT match, but rest matches
-// (gray code equivalent of first MSB different but rest same)
-wire full = wr_ptr_gray_reg == (rd_ptr_gray_sync2_reg ^ {2'b11, {ADDR_WIDTH-1{1'b0}}});
-// empty when pointers match exactly
-wire empty = FRAME_FIFO ? (rd_ptr_reg == wr_ptr_commit_sync_reg) : (rd_ptr_gray_reg == wr_ptr_gray_sync2_reg);
-// overflow within packet
-wire full_wr = wr_ptr_reg == (wr_ptr_commit_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});
-
-// control signals
-reg write;
-reg read;
-reg store_output;
-
-reg s_frame_reg = 1'b0;
-reg m_frame_reg = 1'b0;
-
-reg drop_frame_reg = 1'b0;
-reg mark_frame_reg = 1'b0;
-reg send_frame_reg = 1'b0;
-reg overflow_reg = 1'b0;
-reg bad_frame_reg = 1'b0;
-reg good_frame_reg = 1'b0;
-
-reg m_drop_frame_reg = 1'b0;
-reg m_terminate_frame_reg = 1'b0;
-
-reg [ADDR_WIDTH:0] s_depth_reg = 0;
-reg [ADDR_WIDTH:0] s_depth_commit_reg = 0;
-reg [ADDR_WIDTH:0] m_depth_reg = 0;
-reg [ADDR_WIDTH:0] m_depth_commit_reg = 0;
-
-reg overflow_sync1_reg = 1'b0;
-reg overflow_sync2_reg = 1'b0;
-reg overflow_sync3_reg = 1'b0;
-reg overflow_sync4_reg = 1'b0;
-reg bad_frame_sync1_reg = 1'b0;
-reg bad_frame_sync2_reg = 1'b0;
-reg bad_frame_sync3_reg = 1'b0;
-reg bad_frame_sync4_reg = 1'b0;
-reg good_frame_sync1_reg = 1'b0;
-reg good_frame_sync2_reg = 1'b0;
-reg good_frame_sync3_reg = 1'b0;
-reg good_frame_sync4_reg = 1'b0;
-
-assign s_axis_tready = (FRAME_FIFO ? (!full || (full_wr && DROP_OVERSIZE_FRAME) || DROP_WHEN_FULL) : (!full || MARK_WHEN_FULL)) && !s_rst_sync3_reg;
-
-wire [WIDTH-1:0] s_axis;
-
-generate
-    assign s_axis[DATA_WIDTH-1:0] = s_axis_tdata;
-    if (KEEP_ENABLE) assign s_axis[KEEP_OFFSET +: KEEP_WIDTH] = s_axis_tkeep;
-    if (LAST_ENABLE) assign s_axis[LAST_OFFSET]               = s_axis_tlast | mark_frame_reg;
-    if (ID_ENABLE)   assign s_axis[ID_OFFSET   +: ID_WIDTH]   = s_axis_tid;
-    if (DEST_ENABLE) assign s_axis[DEST_OFFSET +: DEST_WIDTH] = s_axis_tdest;
-    if (USER_ENABLE) assign s_axis[USER_OFFSET +: USER_WIDTH] = mark_frame_reg ? USER_BAD_FRAME_VALUE : s_axis_tuser;
-endgenerate
-
-wire [WIDTH-1:0] m_axis = m_axis_pipe_reg[RAM_PIPELINE+1-1];
-
-wire                   m_axis_tready_pipe;
-wire                   m_axis_tvalid_pipe = m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1];
-
-wire [DATA_WIDTH-1:0]  m_axis_tdata_pipe  = m_axis[DATA_WIDTH-1:0];
-wire [KEEP_WIDTH-1:0]  m_axis_tkeep_pipe  = KEEP_ENABLE ? m_axis[KEEP_OFFSET +: KEEP_WIDTH] : {KEEP_WIDTH{1'b1}};
-wire                   m_axis_tlast_pipe  = LAST_ENABLE ? m_axis[LAST_OFFSET] | m_terminate_frame_reg : 1'b1;
-wire [ID_WIDTH-1:0]    m_axis_tid_pipe    = ID_ENABLE   ? m_axis[ID_OFFSET +: ID_WIDTH] : {ID_WIDTH{1'b0}};
-wire [DEST_WIDTH-1:0]  m_axis_tdest_pipe  = DEST_ENABLE ? m_axis[DEST_OFFSET +: DEST_WIDTH] : {DEST_WIDTH{1'b0}};
-wire [USER_WIDTH-1:0]  m_axis_tuser_pipe  = USER_ENABLE ? (m_terminate_frame_reg ? USER_BAD_FRAME_VALUE : m_axis[USER_OFFSET +: USER_WIDTH]) : {USER_WIDTH{1'b0}};
-
-wire                   m_axis_tready_out;
-wire                   m_axis_tvalid_out;
-
-wire [DATA_WIDTH-1:0]  m_axis_tdata_out;
-wire [KEEP_WIDTH-1:0]  m_axis_tkeep_out;
-wire                   m_axis_tlast_out;
-wire [ID_WIDTH-1:0]    m_axis_tid_out;
-wire [DEST_WIDTH-1:0]  m_axis_tdest_out;
-wire [USER_WIDTH-1:0]  m_axis_tuser_out;
-
-wire pipe_ready;
-
-assign s_status_depth = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {s_depth_reg, {$clog2(KEEP_WIDTH){1'b0}}} : s_depth_reg;
-assign s_status_depth_commit = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {s_depth_commit_reg, {$clog2(KEEP_WIDTH){1'b0}}} : s_depth_commit_reg;
-assign s_status_overflow = overflow_reg;
-assign s_status_bad_frame = bad_frame_reg;
-assign s_status_good_frame = good_frame_reg;
-
-assign m_status_depth = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {m_depth_reg, {$clog2(KEEP_WIDTH){1'b0}}} : m_depth_reg;
-assign m_status_depth_commit = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {m_depth_commit_reg, {$clog2(KEEP_WIDTH){1'b0}}} : m_depth_commit_reg;
-assign m_status_overflow = overflow_sync3_reg ^ overflow_sync4_reg;
-assign m_status_bad_frame = bad_frame_sync3_reg ^ bad_frame_sync4_reg;
-assign m_status_good_frame = good_frame_sync3_reg ^ good_frame_sync4_reg;
-
-// reset synchronization
-always @(posedge m_clk or posedge m_rst) begin
-    if (m_rst) begin
-        s_rst_sync1_reg <= 1'b1;
-    end else begin
-        s_rst_sync1_reg <= 1'b0;
-    end
-end
-
-always @(posedge s_clk) begin
-    s_rst_sync2_reg <= s_rst_sync1_reg;
-    s_rst_sync3_reg <= s_rst_sync2_reg;
-end
+// axis_fifo
+logic fifo_clk;
+logic fifo_rst;
+logic [DATA_WIDTH-1:0] fifo_m_axis_tdata;
+logic [KEEP_WIDTH-1:0] fifo_m_axis_tkeep;
+logic                  fifo_m_axis_tvalid;
+logic                  fifo_m_axis_tready;
+logic                  fifo_m_axis_tlast;
+logic [ID_WIDTH-1:0]   fifo_m_axis_tid;
+logic [DEST_WIDTH-1:0] fifo_m_axis_tdest;
+logic [USER_WIDTH-1:0] fifo_m_axis_tuser;
+
+logic [DATA_WIDTH-1:0] fifo_s_axis_tdata;
+logic [KEEP_WIDTH-1:0] fifo_s_axis_tkeep;
+logic                  fifo_s_axis_tvalid;
+logic                  fifo_s_axis_tready;
+logic                  fifo_s_axis_tlast;
+logic [ID_WIDTH-1:0]   fifo_s_axis_tid;
+logic [DEST_WIDTH-1:0] fifo_s_axis_tdest;
+logic [USER_WIDTH-1:0] fifo_s_axis_tuser;
+
+// Status
+logic fifo_status_overflow;
+logic fifo_status_bad_frame;
+logic fifo_status_good_frame;
+logic fifo_status_overflow_synced;
+logic fifo_status_bad_frame_synced;
+logic fifo_status_good_frame_synced;
+
+// bsg_async_fifo
+logic             w_enq_li;
+logic [WIDTH-1:0] w_data_li;
+logic             w_full_lo;
+logic             r_deq_li;
+logic [WIDTH-1:0] r_data_lo;
+logic             r_valid_lo;
+
+// bsg_launch_sync_sync
+logic iclk_li;
+logic iclk_reset_li;
+logic oclk_li;
+logic oclk_reset_li;
+
+if(upstream_async_fifo_p) begin: up
+
+  // fifo clock, reset
+  assign fifo_clk = m_clk;
+  assign fifo_rst = m_rst;
+  // bsg_launch_sync_sync clock, reset
+  assign iclk_li = m_clk;
+  assign iclk_reset_li = m_rst;
+  assign oclk_li = s_clk;
+  assign oclk_reset_li = s_rst;
+
+  // AXIS input -> bsg_async_fifo
+  assign                  w_data_li[DATA_WIDTH-1:0]            = s_axis_tdata;
+  if (KEEP_ENABLE) assign w_data_li[KEEP_OFFSET +: KEEP_WIDTH] = s_axis_tkeep;
+  if (LAST_ENABLE) assign w_data_li[LAST_OFFSET]               = s_axis_tlast;
+  if (ID_ENABLE)   assign w_data_li[ID_OFFSET   +: ID_WIDTH]   = s_axis_tid;
+  if (DEST_ENABLE) assign w_data_li[DEST_OFFSET +: DEST_WIDTH] = s_axis_tdest;
+  if (USER_ENABLE) assign w_data_li[USER_OFFSET +: USER_WIDTH] = s_axis_tuser;
+
+  assign w_enq_li = s_axis_tvalid & s_axis_tready;
+  assign s_axis_tready = ~w_full_lo;
+
+  // bsg_async_fifo -> axis_fifo
+  assign fifo_s_axis_tvalid = r_valid_lo;
+  assign r_deq_li = fifo_s_axis_tvalid & fifo_s_axis_tready;
+
+  assign   fifo_s_axis_tdata  = r_data_lo[DATA_WIDTH-1:0];
+  if(KEEP_ENABLE)
+    assign fifo_s_axis_tkeep = r_data_lo[KEEP_OFFSET +: KEEP_WIDTH];
+  else
+    assign fifo_s_axis_tkeep = {KEEP_WIDTH{1'b1}};
+  if(LAST_ENABLE)
+    assign fifo_s_axis_tlast = r_data_lo[LAST_OFFSET];
+  else
+    assign fifo_s_axis_tlast = 1'b1;
+  if(ID_ENABLE)
+    assign fifo_s_axis_tid = r_data_lo[ID_OFFSET +: ID_WIDTH];
+  else
+    assign fifo_s_axis_tid = {ID_WIDTH{1'b0}};
+  if(DEST_ENABLE)
+    assign fifo_s_axis_tdest = r_data_lo[DEST_OFFSET +: DEST_WIDTH];
+  else
+    assign fifo_s_axis_tdest = {DEST_WIDTH{1'b0}};
+  if(USER_ENABLE)
+    assign fifo_s_axis_tuser = r_data_lo[USER_OFFSET +: USER_WIDTH];
+  else
+    assign fifo_s_axis_tuser = {USER_WIDTH{1'b0}};
+
+  // axis_fifo -> AXIS output
+  assign m_axis_tdata  = fifo_m_axis_tdata;
+  assign m_axis_tkeep  = fifo_m_axis_tkeep;
+  assign m_axis_tvalid = fifo_m_axis_tvalid;
+  assign m_axis_tlast  = fifo_m_axis_tlast;
+  assign m_axis_tid    = fifo_m_axis_tid;
+  assign m_axis_tdest  = fifo_m_axis_tdest;
+  assign m_axis_tuser  = fifo_m_axis_tuser;
+  assign fifo_m_axis_tready = m_axis_tready;
+  // Status
+  assign s_status_overflow   = fifo_status_overflow_synced;
+  assign s_status_bad_frame  = fifo_status_bad_frame_synced;
+  assign s_status_good_frame = fifo_status_good_frame_synced;
+  assign m_status_overflow   = fifo_status_overflow;
+  assign m_status_bad_frame  = fifo_status_bad_frame;
+  assign m_status_good_frame = fifo_status_good_frame;
+
+end else begin: down
+
+  // fifo clock, reset
+  assign fifo_clk = s_clk;
+  assign fifo_rst = s_rst;
+  // bsg_launch_sync_sync clock, reset
+  assign iclk_li = s_clk;
+  assign iclk_reset_li = s_rst;
+  assign oclk_li = m_clk;
+  assign oclk_reset_li = m_rst;
+
+  // AXIS input -> axis_fifo
+
+  assign fifo_s_axis_tdata  = s_axis_tdata;
+  assign fifo_s_axis_tkeep  = s_axis_tkeep;
+  assign fifo_s_axis_tvalid = s_axis_tvalid;
+  assign fifo_s_axis_tlast  = s_axis_tlast;
+  assign fifo_s_axis_tid    = s_axis_tid;
+  assign fifo_s_axis_tdest  = s_axis_tdest;
+  assign fifo_s_axis_tuser  = s_axis_tuser;
+  assign s_axis_tready = fifo_s_axis_tready;
+
+  // axis_fifo -> bsg_async_fifo
+
+  assign                  w_data_li[DATA_WIDTH-1:0]            = fifo_m_axis_tdata;
+  if (KEEP_ENABLE) assign w_data_li[KEEP_OFFSET +: KEEP_WIDTH] = fifo_m_axis_tkeep;
+  if (LAST_ENABLE) assign w_data_li[LAST_OFFSET]               = fifo_m_axis_tlast;
+  if (ID_ENABLE)   assign w_data_li[ID_OFFSET   +: ID_WIDTH]   = fifo_m_axis_tid;
+  if (DEST_ENABLE) assign w_data_li[DEST_OFFSET +: DEST_WIDTH] = fifo_m_axis_tdest;
+  if (USER_ENABLE) assign w_data_li[USER_OFFSET +: USER_WIDTH] = fifo_m_axis_tuser;
+  assign w_enq_li = fifo_m_axis_tvalid & fifo_m_axis_tready;
+  assign fifo_m_axis_tready = ~w_full_lo;
+
+  // bsg_async_fifo -> AXIS output
+  assign r_deq_li = m_axis_tvalid & m_axis_tready;
+  assign m_axis_tvalid = r_valid_lo;
+
+  assign     m_axis_tdata = r_data_lo[DATA_WIDTH-1:0];
+  if(KEEP_ENABLE)
+    assign m_axis_tkeep = r_data_lo[KEEP_OFFSET +: KEEP_WIDTH];
+  else
+    assign m_axis_tkeep = {KEEP_WIDTH{1'b1}};
+  if(LAST_ENABLE)
+    assign m_axis_tlast = r_data_lo[LAST_OFFSET];
+  else
+    assign m_axis_tlast = 1'b1;
+  if(ID_ENABLE)
+    assign m_axis_tid   = r_data_lo[ID_OFFSET +: ID_WIDTH];
+  else
+    assign m_axis_tid   = {ID_WIDTH{1'b0}};
+  if(DEST_ENABLE)
+    assign m_axis_tdest = r_data_lo[DEST_OFFSET +: DEST_WIDTH];
+  else
+    assign m_axis_tdest = {DEST_WIDTH{1'b0}};
+  if(USER_ENABLE)
+    assign m_axis_tuser = r_data_lo[USER_OFFSET +: USER_WIDTH];
+  else
+    assign m_axis_tuser = {USER_WIDTH{1'b0}};
+
+  // Status
+  assign s_status_overflow   = fifo_status_overflow;
+  assign s_status_bad_frame  = fifo_status_bad_frame;
+  assign s_status_good_frame = fifo_status_good_frame;
+  assign m_status_overflow   = fifo_status_overflow_synced;
+  assign m_status_bad_frame  = fifo_status_bad_frame_synced;
+  assign m_status_good_frame = fifo_status_good_frame_synced;
 
-always @(posedge s_clk or posedge s_rst) begin
-    if (s_rst) begin
-        m_rst_sync1_reg <= 1'b1;
-    end else begin
-        m_rst_sync1_reg <= 1'b0;
-    end
 end
 
-always @(posedge m_clk) begin
-    m_rst_sync2_reg <= m_rst_sync1_reg;
-    m_rst_sync3_reg <= m_rst_sync2_reg;
-end
-
-// Write logic
-always @(posedge s_clk) begin
-    overflow_reg <= 1'b0;
-    bad_frame_reg <= 1'b0;
-    good_frame_reg <= 1'b0;
-
-    if (FRAME_FIFO && wr_ptr_update_valid_reg) begin
-        // have updated pointer to sync
-        if (wr_ptr_update_reg == wr_ptr_update_ack_sync2_reg) begin
-            // no sync in progress; sync update
-            wr_ptr_update_valid_reg <= 1'b0;
-            wr_ptr_sync_commit_reg <= wr_ptr_commit_reg;
-            wr_ptr_update_reg <= !wr_ptr_update_ack_sync2_reg;
-        end
-    end
-
-    if (s_axis_tready && s_axis_tvalid && LAST_ENABLE) begin
-        // track input frame status
-        s_frame_reg <= !s_axis_tlast;
-    end
-
-    if (s_rst_sync3_reg && LAST_ENABLE) begin
-        // if sink side is reset during transfer, drop partial frame
-        if (s_frame_reg && !(s_axis_tready && s_axis_tvalid && s_axis_tlast)) begin
-            drop_frame_reg <= 1'b1;
-        end
-        if (s_axis_tready && s_axis_tvalid && !s_axis_tlast) begin
-            drop_frame_reg <= 1'b1;
-        end
-    end
-
-    if (FRAME_FIFO) begin
-        // frame FIFO mode
-        if (s_axis_tready && s_axis_tvalid) begin
-            // transfer in
-            if ((full && DROP_WHEN_FULL) || (full_wr && DROP_OVERSIZE_FRAME) || drop_frame_reg) begin
-                // full, packet overflow, or currently dropping frame
-                // drop frame
-                drop_frame_reg <= 1'b1;
-                if (s_axis_tlast) begin
-                    // end of frame, reset write pointer
-                    wr_ptr_temp = wr_ptr_commit_reg;
-                    wr_ptr_reg <= wr_ptr_temp;
-                    wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-                    drop_frame_reg <= 1'b0;
-                    overflow_reg <= 1'b1;
-                end
-            end else begin
-                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-                wr_ptr_temp = wr_ptr_reg + 1;
-                wr_ptr_reg <= wr_ptr_temp;
-                wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-                if (s_axis_tlast || (!DROP_OVERSIZE_FRAME && (full_wr || send_frame_reg))) begin
-                    // end of frame or send frame
-                    send_frame_reg <= !s_axis_tlast;
-                    if (s_axis_tlast && DROP_BAD_FRAME && USER_BAD_FRAME_MASK & ~(s_axis_tuser ^ USER_BAD_FRAME_VALUE)) begin
-                        // bad packet, reset write pointer
-                        wr_ptr_temp = wr_ptr_commit_reg;
-                        wr_ptr_reg <= wr_ptr_temp;
-                        wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-                        bad_frame_reg <= 1'b1;
-                    end else begin
-                        // good packet or packet overflow, update write pointer
-                        wr_ptr_temp = wr_ptr_reg + 1;
-                        wr_ptr_reg <= wr_ptr_temp;
-                        wr_ptr_commit_reg <= wr_ptr_temp;
-                        wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-
-                        if (wr_ptr_update_reg == wr_ptr_update_ack_sync2_reg) begin
-                            // no sync in progress; sync update
-                            wr_ptr_update_valid_reg <= 1'b0;
-                            wr_ptr_sync_commit_reg <= wr_ptr_temp;
-                            wr_ptr_update_reg <= !wr_ptr_update_ack_sync2_reg;
-                        end else begin
-                            // sync in progress; flag it for later
-                            wr_ptr_update_valid_reg <= 1'b1;
-                        end
-
-                        good_frame_reg <= s_axis_tlast;
-                    end
-                end
-            end
-        end else if (s_axis_tvalid && full_wr && FRAME_FIFO && !DROP_OVERSIZE_FRAME) begin
-            // data valid with packet overflow
-            // update write pointer
-            send_frame_reg <= 1'b1;
-            wr_ptr_temp = wr_ptr_reg;
-            wr_ptr_reg <= wr_ptr_temp;
-            wr_ptr_commit_reg <= wr_ptr_temp;
-            wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-
-            if (wr_ptr_update_reg == wr_ptr_update_ack_sync2_reg) begin
-                // no sync in progress; sync update
-                wr_ptr_update_valid_reg <= 1'b0;
-                wr_ptr_sync_commit_reg <= wr_ptr_temp;
-                wr_ptr_update_reg <= !wr_ptr_update_ack_sync2_reg;
-            end else begin
-                // sync in progress; flag it for later
-                wr_ptr_update_valid_reg <= 1'b1;
-            end
-        end
-    end else begin
-        // normal FIFO mode
-        if (s_axis_tready && s_axis_tvalid) begin
-            if (drop_frame_reg && LAST_ENABLE) begin
-                // currently dropping frame
-                if (s_axis_tlast) begin
-                    // end of frame
-                    if (!full && mark_frame_reg && MARK_WHEN_FULL) begin
-                        // terminate marked frame
-                        mark_frame_reg <= 1'b0;
-                        mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-                        wr_ptr_temp = wr_ptr_reg + 1;
-                        wr_ptr_reg <= wr_ptr_temp;
-                        wr_ptr_commit_reg <= wr_ptr_temp;
-                        wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-                    end
-                    // end of frame, clear drop flag
-                    drop_frame_reg <= 1'b0;
-                    overflow_reg <= 1'b1;
-                end
-            end else if ((full || mark_frame_reg) && MARK_WHEN_FULL) begin
-                // full or marking frame
-                // drop frame; mark if this isn't the first cycle
-                drop_frame_reg <= 1'b1;
-                mark_frame_reg <= mark_frame_reg || s_frame_reg;
-                if (s_axis_tlast) begin
-                    drop_frame_reg <= 1'b0;
-                    overflow_reg <= 1'b1;
-                end
-            end else begin
-                // transfer in
-                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-                wr_ptr_temp = wr_ptr_reg + 1;
-                wr_ptr_reg <= wr_ptr_temp;
-                wr_ptr_commit_reg <= wr_ptr_temp;
-                wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-            end
-        end else if ((!full && !drop_frame_reg && mark_frame_reg) && MARK_WHEN_FULL) begin
-            // terminate marked frame
-            mark_frame_reg <= 1'b0;
-            mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-            wr_ptr_temp = wr_ptr_reg + 1;
-            wr_ptr_reg <= wr_ptr_temp;
-            wr_ptr_commit_reg <= wr_ptr_temp;
-            wr_ptr_gray_reg <= bin2gray(wr_ptr_temp);
-        end
-    end
-
-    if (s_rst_sync3_reg) begin
-        wr_ptr_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_commit_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_gray_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_sync_commit_reg <= {ADDR_WIDTH+1{1'b0}};
-
-        wr_ptr_update_valid_reg <= 1'b0;
-        wr_ptr_update_reg <= 1'b0;
-    end
-
-    if (s_rst) begin
-        wr_ptr_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_commit_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_gray_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_sync_commit_reg <= {ADDR_WIDTH+1{1'b0}};
-
-        wr_ptr_update_valid_reg <= 1'b0;
-        wr_ptr_update_reg <= 1'b0;
-
-        s_frame_reg <= 1'b0;
-
-        drop_frame_reg <= 1'b0;
-        mark_frame_reg <= 1'b0;
-        send_frame_reg <= 1'b0;
-        overflow_reg <= 1'b0;
-        bad_frame_reg <= 1'b0;
-        good_frame_reg <= 1'b0;
-    end
-end
-
-// Write-side status
-always @(posedge s_clk) begin
-    rd_ptr_conv_reg <= gray2bin(rd_ptr_gray_sync2_reg);
-    s_depth_reg <= wr_ptr_reg - rd_ptr_conv_reg;
-    s_depth_commit_reg <= wr_ptr_commit_reg - rd_ptr_conv_reg;
-end
-
-// pointer synchronization
-always @(posedge s_clk) begin
-    rd_ptr_gray_sync1_reg <= rd_ptr_gray_reg;
-    rd_ptr_gray_sync2_reg <= rd_ptr_gray_sync1_reg;
-    wr_ptr_update_ack_sync1_reg <= wr_ptr_update_sync3_reg;
-    wr_ptr_update_ack_sync2_reg <= wr_ptr_update_ack_sync1_reg;
-
-    if (s_rst) begin
-        rd_ptr_gray_sync1_reg <= {ADDR_WIDTH+1{1'b0}};
-        rd_ptr_gray_sync2_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_update_ack_sync1_reg <= 1'b0;
-        wr_ptr_update_ack_sync2_reg <= 1'b0;
-    end
-end
-
-always @(posedge m_clk) begin
-    wr_ptr_gray_sync1_reg <= wr_ptr_gray_reg;
-    wr_ptr_gray_sync2_reg <= wr_ptr_gray_sync1_reg;
-    if (FRAME_FIFO && wr_ptr_update_sync2_reg ^ wr_ptr_update_sync3_reg) begin
-        wr_ptr_commit_sync_reg <= wr_ptr_sync_commit_reg;
-    end
-    wr_ptr_update_sync1_reg <= wr_ptr_update_reg;
-    wr_ptr_update_sync2_reg <= wr_ptr_update_sync1_reg;
-    wr_ptr_update_sync3_reg <= wr_ptr_update_sync2_reg;
-
-    if (FRAME_FIFO && m_rst_sync3_reg) begin
-        wr_ptr_gray_sync1_reg <= {ADDR_WIDTH+1{1'b0}};
-    end
-
-    if (m_rst) begin
-        wr_ptr_gray_sync1_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_gray_sync2_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_commit_sync_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_update_sync1_reg <= 1'b0;
-        wr_ptr_update_sync2_reg <= 1'b0;
-        wr_ptr_update_sync3_reg <= 1'b0;
-    end
-end
-
-// status synchronization
-always @(posedge s_clk) begin
-    overflow_sync1_reg <= overflow_sync1_reg ^ overflow_reg;
-    bad_frame_sync1_reg <= bad_frame_sync1_reg ^ bad_frame_reg;
-    good_frame_sync1_reg <= good_frame_sync1_reg ^ good_frame_reg;
-
-    if (s_rst) begin
-        overflow_sync1_reg <= 1'b0;
-        bad_frame_sync1_reg <= 1'b0;
-        good_frame_sync1_reg <= 1'b0;
-    end
-end
-
-always @(posedge m_clk) begin
-    overflow_sync2_reg <= overflow_sync1_reg;
-    overflow_sync3_reg <= overflow_sync2_reg;
-    overflow_sync4_reg <= overflow_sync3_reg;
-    bad_frame_sync2_reg <= bad_frame_sync1_reg;
-    bad_frame_sync3_reg <= bad_frame_sync2_reg;
-    bad_frame_sync4_reg <= bad_frame_sync3_reg;
-    good_frame_sync2_reg <= good_frame_sync1_reg;
-    good_frame_sync3_reg <= good_frame_sync2_reg;
-    good_frame_sync4_reg <= good_frame_sync3_reg;
-
-    if (m_rst) begin
-        overflow_sync2_reg <= 1'b0;
-        overflow_sync3_reg <= 1'b0;
-        overflow_sync4_reg <= 1'b0;
-        bad_frame_sync2_reg <= 1'b0;
-        bad_frame_sync3_reg <= 1'b0;
-        bad_frame_sync4_reg <= 1'b0;
-        good_frame_sync2_reg <= 1'b0;
-        good_frame_sync3_reg <= 1'b0;
-        good_frame_sync4_reg <= 1'b0;
-    end
-end
-
-// Read logic
-integer j;
-
-always @(posedge m_clk) begin
-    if (m_axis_tready_pipe) begin
-        // output ready; invalidate stage
-        m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1] <= 1'b0;
-        m_terminate_frame_reg <= 1'b0;
-    end
-
-    for (j = RAM_PIPELINE+1-1; j > 0; j = j - 1) begin
-        if (m_axis_tready_pipe || ((~m_axis_tvalid_pipe_reg) >> j)) begin
-            // output ready or bubble in pipeline; transfer down pipeline
-            m_axis_tvalid_pipe_reg[j] <= m_axis_tvalid_pipe_reg[j-1];
-            m_axis_pipe_reg[j] <= m_axis_pipe_reg[j-1];
-            m_axis_tvalid_pipe_reg[j-1] <= 1'b0;
-        end
-    end
-
-    if (m_axis_tready_pipe || ~m_axis_tvalid_pipe_reg) begin
-        // output ready or bubble in pipeline; read new data from FIFO
-        m_axis_tvalid_pipe_reg[0] <= 1'b0;
-        m_axis_pipe_reg[0] <= mem[rd_ptr_reg[ADDR_WIDTH-1:0]];
-        if (!empty && !m_rst_sync3_reg && !m_drop_frame_reg && pipe_ready) begin
-            // not empty, increment pointer
-            m_axis_tvalid_pipe_reg[0] <= 1'b1;
-            rd_ptr_temp = rd_ptr_reg + 1;
-            rd_ptr_reg <= rd_ptr_temp;
-            rd_ptr_gray_reg <= rd_ptr_temp ^ (rd_ptr_temp >> 1);
-        end
-    end
-
-    if (m_axis_tvalid_pipe && LAST_ENABLE) begin
-        // track output frame status
-        if (m_axis_tlast_pipe && m_axis_tready_pipe) begin
-            m_frame_reg <= 1'b0;
-        end else begin
-            m_frame_reg <= 1'b1;
-        end
-    end
-
-    if (m_drop_frame_reg && (OUTPUT_FIFO_ENABLE ? pipe_ready : m_axis_tready_pipe || !m_axis_tvalid_pipe) && LAST_ENABLE) begin
-        // terminate frame
-        // (only for frame transfers interrupted by source reset)
-        m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1] <= 1'b1;
-        m_terminate_frame_reg <= 1'b1;
-        m_drop_frame_reg <= 1'b0;
-    end
-
-    if (m_rst_sync3_reg && LAST_ENABLE) begin
-        // if source side is reset during transfer, drop partial frame
-
-        // empty output pipeline, except for last stage
-        if (RAM_PIPELINE > 0) begin
-            m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-2:0] <= 0;
-        end
-
-        if (m_frame_reg && (!m_axis_tvalid_pipe || (m_axis_tvalid_pipe && !m_axis_tlast_pipe)) &&
-                !(m_drop_frame_reg || m_terminate_frame_reg)) begin
-            // terminate frame
-            m_drop_frame_reg <= 1'b1;
-        end
-    end
-
-    if (m_rst_sync3_reg) begin
-        rd_ptr_reg <= {ADDR_WIDTH+1{1'b0}};
-        rd_ptr_gray_reg <= {ADDR_WIDTH+1{1'b0}};
-    end
-
-    if (m_rst) begin
-        rd_ptr_reg <= {ADDR_WIDTH+1{1'b0}};
-        rd_ptr_gray_reg <= {ADDR_WIDTH+1{1'b0}};
-        m_axis_tvalid_pipe_reg <= 0;
-        m_frame_reg <= 1'b0;
-        m_drop_frame_reg <= 1'b0;
-        m_terminate_frame_reg <= 1'b0;
-    end
-end
-
-// Read-side status
-always @(posedge m_clk) begin
-    wr_ptr_conv_reg <= gray2bin(wr_ptr_gray_sync2_reg);
-    m_depth_reg <= wr_ptr_conv_reg - rd_ptr_reg;
-    m_depth_commit_reg <= FRAME_FIFO ? wr_ptr_commit_sync_reg - rd_ptr_reg : wr_ptr_conv_reg - rd_ptr_reg;
-end
-
-generate
-
-if (!OUTPUT_FIFO_ENABLE) begin
-
-    assign pipe_ready = 1'b1;
-
-    assign m_axis_tready_pipe = m_axis_tready_out;
-    assign m_axis_tvalid_out = m_axis_tvalid_pipe;
-
-    assign m_axis_tdata_out = m_axis_tdata_pipe;
-    assign m_axis_tkeep_out = m_axis_tkeep_pipe;
-    assign m_axis_tlast_out = m_axis_tlast_pipe;
-    assign m_axis_tid_out   = m_axis_tid_pipe;
-    assign m_axis_tdest_out = m_axis_tdest_pipe;
-    assign m_axis_tuser_out = m_axis_tuser_pipe;
-
-end else begin : output_fifo
-
-    // output datapath logic
-    reg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};
-    reg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};
-    reg                  m_axis_tvalid_reg = 1'b0;
-    reg                  m_axis_tlast_reg  = 1'b0;
-    reg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};
-    reg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};
-    reg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};
-
-    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_wr_ptr_reg = 0;
-    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_rd_ptr_reg = 0;
-    reg out_fifo_half_full_reg = 1'b0;
-
-    wire out_fifo_full = out_fifo_wr_ptr_reg == (out_fifo_rd_ptr_reg ^ {1'b1, {OUTPUT_FIFO_ADDR_WIDTH{1'b0}}});
-    wire out_fifo_empty = out_fifo_wr_ptr_reg == out_fifo_rd_ptr_reg;
-
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [DATA_WIDTH-1:0] out_fifo_tdata[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [KEEP_WIDTH-1:0] out_fifo_tkeep[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg                  out_fifo_tlast[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [ID_WIDTH-1:0]   out_fifo_tid[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [DEST_WIDTH-1:0] out_fifo_tdest[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [USER_WIDTH-1:0] out_fifo_tuser[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-
-    assign pipe_ready = !out_fifo_half_full_reg;
-
-    assign m_axis_tready_pipe = 1'b1;
-
-    assign m_axis_tdata_out  = m_axis_tdata_reg;
-    assign m_axis_tkeep_out  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};
-    assign m_axis_tvalid_out = m_axis_tvalid_reg;
-    assign m_axis_tlast_out  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;
-    assign m_axis_tid_out    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};
-    assign m_axis_tdest_out  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};
-    assign m_axis_tuser_out  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};
-
-    always @(posedge m_clk) begin
-        m_axis_tvalid_reg <= m_axis_tvalid_reg && !m_axis_tready_out;
-
-        out_fifo_half_full_reg <= $unsigned(out_fifo_wr_ptr_reg - out_fifo_rd_ptr_reg) >= 2**(OUTPUT_FIFO_ADDR_WIDTH-1);
-
-        if (!out_fifo_full && m_axis_tvalid_pipe) begin
-            out_fifo_tdata[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdata_pipe;
-            out_fifo_tkeep[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tkeep_pipe;
-            out_fifo_tlast[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tlast_pipe;
-            out_fifo_tid[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tid_pipe;
-            out_fifo_tdest[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdest_pipe;
-            out_fifo_tuser[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tuser_pipe;
-            out_fifo_wr_ptr_reg <= out_fifo_wr_ptr_reg + 1;
-        end
-
-        if (!out_fifo_empty && (!m_axis_tvalid_reg || m_axis_tready_out)) begin
-            m_axis_tdata_reg <= out_fifo_tdata[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tkeep_reg <= out_fifo_tkeep[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tvalid_reg <= 1'b1;
-            m_axis_tlast_reg <= out_fifo_tlast[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tid_reg <= out_fifo_tid[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tdest_reg <= out_fifo_tdest[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tuser_reg <= out_fifo_tuser[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            out_fifo_rd_ptr_reg <= out_fifo_rd_ptr_reg + 1;
-        end
-
-        if (m_rst) begin
-            out_fifo_wr_ptr_reg <= 0;
-            out_fifo_rd_ptr_reg <= 0;
-            m_axis_tvalid_reg <= 1'b0;
-        end
-    end
-
-end
-
-if (PAUSE_ENABLE) begin : pause
-
-    // Pause logic
-    reg pause_reg = 1'b0;
-    reg pause_frame_reg = 1'b0;
-
-    reg s_pause_req_sync1_reg;
-    reg s_pause_req_sync2_reg;
-    reg s_pause_req_sync3_reg;
-    reg s_pause_ack_sync1_reg;
-    reg s_pause_ack_sync2_reg;
-    reg s_pause_ack_sync3_reg;
-
-    always @(posedge s_clk) begin
-        s_pause_req_sync1_reg <= s_pause_req;
-        s_pause_ack_sync2_reg <= s_pause_ack_sync1_reg;
-        s_pause_ack_sync3_reg <= s_pause_ack_sync2_reg;
-    end
-
-    always @(posedge m_clk) begin
-        s_pause_req_sync2_reg <= s_pause_req_sync1_reg;
-        s_pause_req_sync3_reg <= s_pause_req_sync2_reg;
-        s_pause_ack_sync1_reg <= pause_reg;
-    end
-
-    assign m_axis_tready_out = m_axis_tready && !pause_reg;
-    assign m_axis_tvalid = m_axis_tvalid_out && !pause_reg;
-
-    assign m_axis_tdata = m_axis_tdata_out;
-    assign m_axis_tkeep = m_axis_tkeep_out;
-    assign m_axis_tlast = m_axis_tlast_out;
-    assign m_axis_tid   = m_axis_tid_out;
-    assign m_axis_tdest = m_axis_tdest_out;
-    assign m_axis_tuser = m_axis_tuser_out;
-
-    assign s_pause_ack = s_pause_ack_sync3_reg;
-    assign m_pause_ack = pause_reg;
-
-    always @(posedge m_clk) begin
-        if (FRAME_PAUSE) begin
-            if (pause_reg) begin
-                // paused; update pause status
-                pause_reg <= m_pause_req || s_pause_req_sync3_reg;
-            end else if (m_axis_tvalid_out) begin
-                // frame transfer; set frame bit
-                pause_frame_reg <= 1'b1;
-                if (m_axis_tready && m_axis_tlast) begin
-                    // end of frame; clear frame bit and update pause status
-                    pause_frame_reg <= 1'b0;
-                    pause_reg <= m_pause_req || s_pause_req_sync3_reg;
-                end
-            end else if (!pause_frame_reg) begin
-                // idle; update pause status
-                pause_reg <= m_pause_req || s_pause_req_sync3_reg;
-            end
-        end else begin
-            pause_reg <= m_pause_req || s_pause_req_sync3_reg;
-        end
-
-        if (m_rst) begin
-            pause_frame_reg <= 1'b0;
-            pause_reg <= 1'b0;
-        end
-    end
-
-end else begin
-
-    assign m_axis_tready_out = m_axis_tready;
-    assign m_axis_tvalid = m_axis_tvalid_out;
-
-    assign m_axis_tdata = m_axis_tdata_out;
-    assign m_axis_tkeep = m_axis_tkeep_out;
-    assign m_axis_tlast = m_axis_tlast_out;
-    assign m_axis_tid   = m_axis_tid_out;
-    assign m_axis_tdest = m_axis_tdest_out;
-    assign m_axis_tuser = m_axis_tuser_out;
-
-    assign s_pause_ack = 1'b0;
-    assign m_pause_ack = 1'b0;
+bsg_async_fifo #(
+   .lg_size_p(3)
+  ,.width_p(WIDTH)
+) cdc (
+   .w_clk_i(s_clk)
+  ,.w_reset_i(s_rst)
+  ,.w_enq_i(w_enq_li)
+  ,.w_data_i(w_data_li)
+  ,.w_full_o(w_full_lo)
+  ,.r_clk_i(m_clk)
+  ,.r_reset_i(m_rst)
+  ,.r_deq_i(r_deq_li)
+  ,.r_data_o(r_data_lo)
+  ,.r_valid_o(r_valid_lo)
+);
 
-end
+axis_fifo #(
+   .DEPTH(DEPTH)
+  ,.DATA_WIDTH(DATA_WIDTH)
+  ,.KEEP_ENABLE(KEEP_ENABLE)
+  ,.KEEP_WIDTH(KEEP_WIDTH)
+  ,.LAST_ENABLE(LAST_ENABLE)
+  ,.ID_ENABLE(ID_ENABLE)
+  ,.ID_WIDTH(ID_WIDTH)
+  ,.DEST_ENABLE(DEST_ENABLE)
+  ,.DEST_WIDTH(DEST_WIDTH)
+  ,.USER_ENABLE(USER_ENABLE)
+  ,.USER_WIDTH(USER_WIDTH)
+  ,.PIPELINE_OUTPUT(PIPELINE_OUTPUT)
+  ,.FRAME_FIFO(FRAME_FIFO)
+  ,.USER_BAD_FRAME_VALUE(USER_BAD_FRAME_VALUE)
+  ,.USER_BAD_FRAME_MASK(USER_BAD_FRAME_MASK)
+  ,.DROP_OVERSIZE_FRAME(DROP_OVERSIZE_FRAME)
+  ,.DROP_BAD_FRAME(DROP_BAD_FRAME)
+  ,.DROP_WHEN_FULL(DROP_WHEN_FULL)
+) fifo (
+   .clk(fifo_clk)
+  ,.rst(fifo_rst)
+
+  ,.s_axis_tdata (fifo_s_axis_tdata)
+  ,.s_axis_tkeep (fifo_s_axis_tkeep)
+  ,.s_axis_tvalid(fifo_s_axis_tvalid)
+  ,.s_axis_tready(fifo_s_axis_tready)
+  ,.s_axis_tlast (fifo_s_axis_tlast)
+  ,.s_axis_tid   (fifo_s_axis_tid)
+  ,.s_axis_tdest (fifo_s_axis_tdest)
+  ,.s_axis_tuser (fifo_s_axis_tuser)
+
+  ,.m_axis_tdata (fifo_m_axis_tdata)
+  ,.m_axis_tkeep (fifo_m_axis_tkeep)
+  ,.m_axis_tvalid(fifo_m_axis_tvalid)
+  ,.m_axis_tready(fifo_m_axis_tready)
+  ,.m_axis_tlast (fifo_m_axis_tlast)
+  ,.m_axis_tid   (fifo_m_axis_tid)
+  ,.m_axis_tdest (fifo_m_axis_tdest)
+  ,.m_axis_tuser (fifo_m_axis_tuser)
+
+  ,.status_overflow  (fifo_status_overflow)
+  ,.status_bad_frame (fifo_status_bad_frame)
+  ,.status_good_frame(fifo_status_good_frame)
+);
+logic overflow_sync1_reg, overflow_sync3_reg, overflow_sync4_reg;
+logic bad_frame_sync1_reg, bad_frame_sync3_reg, bad_frame_sync4_reg;
+logic good_frame_sync1_reg, good_frame_sync3_reg, good_frame_sync4_reg;
+
+wire  overflow_sync1_next   = overflow_sync1_reg   ^ fifo_status_overflow;
+wire  bad_frame_sync1_next  = bad_frame_sync1_reg  ^ fifo_status_bad_frame;
+wire  good_frame_sync1_next = good_frame_sync1_reg ^ fifo_status_good_frame;
+
+assign fifo_status_overflow_synced   = overflow_sync3_reg ^ overflow_sync4_reg;
+assign fifo_status_bad_frame_synced  = bad_frame_sync3_reg ^ bad_frame_sync4_reg;
+assign fifo_status_good_frame_synced = good_frame_sync3_reg ^ good_frame_sync4_reg;
+
+bsg_dff_reset #(
+   .width_p(3)
+) status (
+   .clk_i(oclk_li)
+  ,.reset_i(oclk_reset_li)
+  ,.data_i({overflow_sync3_reg, bad_frame_sync3_reg, good_frame_sync3_reg})
+  ,.data_o({overflow_sync4_reg, bad_frame_sync4_reg, good_frame_sync4_reg})
+);
 
-endgenerate
+bsg_launch_sync_sync #(
+  .width_p(3),
+  .use_negedge_for_launch_p(0),
+  .use_async_reset_p(0)
+) status_synchronizer (
+  .iclk_i(iclk_li),
+  .iclk_reset_i(iclk_reset_li),
+  .oclk_i(oclk_li),
+  .iclk_data_i({overflow_sync1_next, bad_frame_sync1_next, good_frame_sync1_next}),
+  .iclk_data_o({overflow_sync1_reg, bad_frame_sync1_reg, good_frame_sync1_reg}),
+  .oclk_data_o({overflow_sync3_reg, bad_frame_sync3_reg, good_frame_sync3_reg})
+);
 
 endmodule
-
-`resetall
diff --git a/lib/axis/rtl/axis_async_fifo_adapter.v b/lib/axis/rtl/axis_async_fifo_adapter.v
index 7796996..d2943de 100644
--- a/lib/axis/rtl/axis_async_fifo_adapter.v
+++ b/lib/axis/rtl/axis_async_fifo_adapter.v
@@ -24,9 +24,7 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
+`include "bsg_defines.sv"
 
 /*
  * AXI4-Stream asynchronous FIFO with width converter
@@ -43,14 +41,14 @@ module axis_async_fifo_adapter #
     // If disabled, tkeep assumed to be 1'b1
     parameter S_KEEP_ENABLE = (S_DATA_WIDTH>8),
     // tkeep signal width (words per cycle) on input interface
-    parameter S_KEEP_WIDTH = ((S_DATA_WIDTH+7)/8),
+    parameter S_KEEP_WIDTH = (S_DATA_WIDTH/8),
     // Width of output AXI stream interface in bits
     parameter M_DATA_WIDTH = 8,
     // Propagate tkeep signal on output interface
     // If disabled, tkeep assumed to be 1'b1
     parameter M_KEEP_ENABLE = (M_DATA_WIDTH>8),
     // tkeep signal width (words per cycle) on output interface
-    parameter M_KEEP_WIDTH = ((M_DATA_WIDTH+7)/8),
+    parameter M_KEEP_WIDTH = (M_DATA_WIDTH/8),
     // Propagate tid signal
     parameter ID_ENABLE = 0,
     // tid signal width
@@ -63,11 +61,8 @@ module axis_async_fifo_adapter #
     parameter USER_ENABLE = 1,
     // tuser signal width
     parameter USER_WIDTH = 1,
-    // number of RAM pipeline registers in FIFO
-    parameter RAM_PIPELINE = 1,
-    // use output FIFO
-    // When set, the RAM read enable and pipeline clock enables are removed
-    parameter OUTPUT_FIFO_ENABLE = 0,
+    // number of output pipeline registers
+    parameter PIPELINE_OUTPUT = 2,
     // Frame FIFO mode - operate on frames instead of cycles
     // When set, m_axis_tvalid will not be deasserted within a frame
     // Requires LAST_ENABLE set
@@ -86,14 +81,8 @@ module axis_async_fifo_adapter #
     // When set, s_axis_tready is always asserted
     // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set
     parameter DROP_WHEN_FULL = 0,
-    // Mark incoming frames as bad frames when full
-    // When set, s_axis_tready is always asserted
-    // Requires FRAME_FIFO to be clear
-    parameter MARK_WHEN_FULL = 0,
-    // Enable pause request input
-    parameter PAUSE_ENABLE = 0,
-    // Pause between frames
-    parameter FRAME_PAUSE = FRAME_FIFO
+    // put an async FIFO either on upstream or downstream
+    parameter `BSG_INV_PARAM(upstream_async_fifo_p)
 )
 (
     /*
@@ -124,56 +113,44 @@ module axis_async_fifo_adapter #
     output wire [DEST_WIDTH-1:0]    m_axis_tdest,
     output wire [USER_WIDTH-1:0]    m_axis_tuser,
 
-    /*
-     * Pause
-     */
-    input  wire                     s_pause_req,
-    output wire                     s_pause_ack,
-    input  wire                     m_pause_req,
-    output wire                     m_pause_ack,
-
     /*
      * Status
      */
-    output wire [$clog2(DEPTH):0]   s_status_depth,
-    output wire [$clog2(DEPTH):0]   s_status_depth_commit,
     output wire                     s_status_overflow,
     output wire                     s_status_bad_frame,
     output wire                     s_status_good_frame,
-    output wire [$clog2(DEPTH):0]   m_status_depth,
-    output wire [$clog2(DEPTH):0]   m_status_depth_commit,
     output wire                     m_status_overflow,
     output wire                     m_status_bad_frame,
     output wire                     m_status_good_frame
 );
 
 // force keep width to 1 when disabled
-localparam S_BYTE_LANES = S_KEEP_ENABLE ? S_KEEP_WIDTH : 1;
-localparam M_BYTE_LANES = M_KEEP_ENABLE ? M_KEEP_WIDTH : 1;
+parameter S_KEEP_WIDTH_INT = S_KEEP_ENABLE ? S_KEEP_WIDTH : 1;
+parameter M_KEEP_WIDTH_INT = M_KEEP_ENABLE ? M_KEEP_WIDTH : 1;
 
-// bus byte sizes (must be identical)
-localparam S_BYTE_SIZE = S_DATA_WIDTH / S_BYTE_LANES;
-localparam M_BYTE_SIZE = M_DATA_WIDTH / M_BYTE_LANES;
+// bus word sizes (must be identical)
+parameter S_DATA_WORD_SIZE = S_DATA_WIDTH / S_KEEP_WIDTH_INT;
+parameter M_DATA_WORD_SIZE = M_DATA_WIDTH / M_KEEP_WIDTH_INT;
 // output bus is wider
-localparam EXPAND_BUS = M_BYTE_LANES > S_BYTE_LANES;
+parameter EXPAND_BUS = M_KEEP_WIDTH_INT > S_KEEP_WIDTH_INT;
 // total data and keep widths
-localparam DATA_WIDTH = EXPAND_BUS ? M_DATA_WIDTH : S_DATA_WIDTH;
-localparam KEEP_WIDTH = EXPAND_BUS ? M_BYTE_LANES : S_BYTE_LANES;
+parameter DATA_WIDTH = EXPAND_BUS ? M_DATA_WIDTH : S_DATA_WIDTH;
+parameter KEEP_WIDTH = EXPAND_BUS ? M_KEEP_WIDTH_INT : S_KEEP_WIDTH_INT;
 
 // bus width assertions
 initial begin
-    if (S_BYTE_SIZE * S_BYTE_LANES != S_DATA_WIDTH) begin
-        $error("Error: input data width not evenly divisible (instance %m)");
+    if (S_DATA_WORD_SIZE * S_KEEP_WIDTH_INT != S_DATA_WIDTH) begin
+        $error("Error: input data width not evenly divisble (instance %m)");
         $finish;
     end
 
-    if (M_BYTE_SIZE * M_BYTE_LANES != M_DATA_WIDTH) begin
-        $error("Error: output data width not evenly divisible (instance %m)");
+    if (M_DATA_WORD_SIZE * M_KEEP_WIDTH_INT != M_DATA_WIDTH) begin
+        $error("Error: output data width not evenly divisble (instance %m)");
         $finish;
     end
 
-    if (S_BYTE_SIZE != M_BYTE_SIZE) begin
-        $error("Error: byte size mismatch (instance %m)");
+    if (S_DATA_WORD_SIZE != M_DATA_WORD_SIZE) begin
+        $error("Error: word size mismatch (instance %m)");
         $finish;
     end
 end
@@ -198,7 +175,30 @@ wire [USER_WIDTH-1:0]  post_fifo_axis_tuser;
 
 generate
 
-if (M_BYTE_LANES > S_BYTE_LANES) begin : upsize_pre
+if (M_KEEP_WIDTH == S_KEEP_WIDTH) begin
+
+    // same width, no adapter needed
+
+    assign pre_fifo_axis_tdata = s_axis_tdata;
+    assign pre_fifo_axis_tkeep = s_axis_tkeep;
+    assign pre_fifo_axis_tvalid = s_axis_tvalid;
+    assign s_axis_tready = pre_fifo_axis_tready;
+    assign pre_fifo_axis_tlast = s_axis_tlast;
+    assign pre_fifo_axis_tid = s_axis_tid;
+    assign pre_fifo_axis_tdest = s_axis_tdest;
+    assign pre_fifo_axis_tuser = s_axis_tuser;
+
+    assign m_axis_tdata = post_fifo_axis_tdata;
+    assign m_axis_tkeep = post_fifo_axis_tkeep;
+    assign m_axis_tvalid = post_fifo_axis_tvalid;
+    assign post_fifo_axis_tready = m_axis_tready;
+    assign m_axis_tlast = post_fifo_axis_tlast;
+    assign m_axis_tid = post_fifo_axis_tid;
+    assign m_axis_tdest = post_fifo_axis_tdest;
+    assign m_axis_tuser = post_fifo_axis_tuser;
+
+
+end else if (EXPAND_BUS) begin
 
     // output wider, adapt width before FIFO
 
@@ -239,7 +239,18 @@ if (M_BYTE_LANES > S_BYTE_LANES) begin : upsize_pre
         .m_axis_tuser(pre_fifo_axis_tuser)
     );
 
-end else begin : bypass_pre
+    assign m_axis_tdata = post_fifo_axis_tdata;
+    assign m_axis_tkeep = post_fifo_axis_tkeep;
+    assign m_axis_tvalid = post_fifo_axis_tvalid;
+    assign post_fifo_axis_tready = m_axis_tready;
+    assign m_axis_tlast = post_fifo_axis_tlast;
+    assign m_axis_tid = post_fifo_axis_tid;
+    assign m_axis_tdest = post_fifo_axis_tdest;
+    assign m_axis_tuser = post_fifo_axis_tuser;
+
+end else begin
+
+    // input wider, adapt width after FIFO
 
     assign pre_fifo_axis_tdata = s_axis_tdata;
     assign pre_fifo_axis_tkeep = s_axis_tkeep;
@@ -250,8 +261,47 @@ end else begin : bypass_pre
     assign pre_fifo_axis_tdest = s_axis_tdest;
     assign pre_fifo_axis_tuser = s_axis_tuser;
 
+    axis_adapter #(
+        .S_DATA_WIDTH(S_DATA_WIDTH),
+        .S_KEEP_ENABLE(S_KEEP_ENABLE),
+        .S_KEEP_WIDTH(S_KEEP_WIDTH),
+        .M_DATA_WIDTH(M_DATA_WIDTH),
+        .M_KEEP_ENABLE(M_KEEP_ENABLE),
+        .M_KEEP_WIDTH(M_KEEP_WIDTH),
+        .ID_ENABLE(ID_ENABLE),
+        .ID_WIDTH(ID_WIDTH),
+        .DEST_ENABLE(DEST_ENABLE),
+        .DEST_WIDTH(DEST_WIDTH),
+        .USER_ENABLE(USER_ENABLE),
+        .USER_WIDTH(USER_WIDTH)
+    )
+    adapter_inst (
+        .clk(m_clk),
+        .rst(m_rst),
+        // AXI input
+        .s_axis_tdata(post_fifo_axis_tdata),
+        .s_axis_tkeep(post_fifo_axis_tkeep),
+        .s_axis_tvalid(post_fifo_axis_tvalid),
+        .s_axis_tready(post_fifo_axis_tready),
+        .s_axis_tlast(post_fifo_axis_tlast),
+        .s_axis_tid(post_fifo_axis_tid),
+        .s_axis_tdest(post_fifo_axis_tdest),
+        .s_axis_tuser(post_fifo_axis_tuser),
+        // AXI output
+        .m_axis_tdata(m_axis_tdata),
+        .m_axis_tkeep(m_axis_tkeep),
+        .m_axis_tvalid(m_axis_tvalid),
+        .m_axis_tready(m_axis_tready),
+        .m_axis_tlast(m_axis_tlast),
+        .m_axis_tid(m_axis_tid),
+        .m_axis_tdest(m_axis_tdest),
+        .m_axis_tuser(m_axis_tuser)
+    );
+
 end
 
+endgenerate
+
 axis_async_fifo #(
     .DEPTH(DEPTH),
     .DATA_WIDTH(DATA_WIDTH),
@@ -264,17 +314,14 @@ axis_async_fifo #(
     .DEST_WIDTH(DEST_WIDTH),
     .USER_ENABLE(USER_ENABLE),
     .USER_WIDTH(USER_WIDTH),
-    .RAM_PIPELINE(RAM_PIPELINE),
-    .OUTPUT_FIFO_ENABLE(OUTPUT_FIFO_ENABLE),
+    .PIPELINE_OUTPUT(PIPELINE_OUTPUT),
     .FRAME_FIFO(FRAME_FIFO),
     .USER_BAD_FRAME_VALUE(USER_BAD_FRAME_VALUE),
     .USER_BAD_FRAME_MASK(USER_BAD_FRAME_MASK),
     .DROP_OVERSIZE_FRAME(DROP_OVERSIZE_FRAME),
     .DROP_BAD_FRAME(DROP_BAD_FRAME),
     .DROP_WHEN_FULL(DROP_WHEN_FULL),
-    .MARK_WHEN_FULL(MARK_WHEN_FULL),
-    .PAUSE_ENABLE(PAUSE_ENABLE),
-    .FRAME_PAUSE(FRAME_PAUSE)
+    .upstream_async_fifo_p(upstream_async_fifo_p)
 )
 fifo_inst (
     // AXI input
@@ -299,80 +346,15 @@ fifo_inst (
     .m_axis_tid(post_fifo_axis_tid),
     .m_axis_tdest(post_fifo_axis_tdest),
     .m_axis_tuser(post_fifo_axis_tuser),
-    // Pause
-    .s_pause_req(s_pause_req),
-    .s_pause_ack(s_pause_ack),
-    .m_pause_req(m_pause_req),
-    .m_pause_ack(m_pause_ack),
     // Status
-    .s_status_depth(s_status_depth),
-    .s_status_depth_commit(s_status_depth_commit),
     .s_status_overflow(s_status_overflow),
     .s_status_bad_frame(s_status_bad_frame),
     .s_status_good_frame(s_status_good_frame),
-    .m_status_depth(m_status_depth),
-    .m_status_depth_commit(m_status_depth_commit),
     .m_status_overflow(m_status_overflow),
     .m_status_bad_frame(m_status_bad_frame),
     .m_status_good_frame(m_status_good_frame)
 );
 
-if (M_BYTE_LANES < S_BYTE_LANES) begin : downsize_post
-
-    // input wider, adapt width after FIFO
-
-    axis_adapter #(
-        .S_DATA_WIDTH(S_DATA_WIDTH),
-        .S_KEEP_ENABLE(S_KEEP_ENABLE),
-        .S_KEEP_WIDTH(S_KEEP_WIDTH),
-        .M_DATA_WIDTH(M_DATA_WIDTH),
-        .M_KEEP_ENABLE(M_KEEP_ENABLE),
-        .M_KEEP_WIDTH(M_KEEP_WIDTH),
-        .ID_ENABLE(ID_ENABLE),
-        .ID_WIDTH(ID_WIDTH),
-        .DEST_ENABLE(DEST_ENABLE),
-        .DEST_WIDTH(DEST_WIDTH),
-        .USER_ENABLE(USER_ENABLE),
-        .USER_WIDTH(USER_WIDTH)
-    )
-    adapter_inst (
-        .clk(m_clk),
-        .rst(m_rst),
-        // AXI input
-        .s_axis_tdata(post_fifo_axis_tdata),
-        .s_axis_tkeep(post_fifo_axis_tkeep),
-        .s_axis_tvalid(post_fifo_axis_tvalid),
-        .s_axis_tready(post_fifo_axis_tready),
-        .s_axis_tlast(post_fifo_axis_tlast),
-        .s_axis_tid(post_fifo_axis_tid),
-        .s_axis_tdest(post_fifo_axis_tdest),
-        .s_axis_tuser(post_fifo_axis_tuser),
-        // AXI output
-        .m_axis_tdata(m_axis_tdata),
-        .m_axis_tkeep(m_axis_tkeep),
-        .m_axis_tvalid(m_axis_tvalid),
-        .m_axis_tready(m_axis_tready),
-        .m_axis_tlast(m_axis_tlast),
-        .m_axis_tid(m_axis_tid),
-        .m_axis_tdest(m_axis_tdest),
-        .m_axis_tuser(m_axis_tuser)
-    );
-
-end else begin : bypass_post
-
-    assign m_axis_tdata = post_fifo_axis_tdata;
-    assign m_axis_tkeep = post_fifo_axis_tkeep;
-    assign m_axis_tvalid = post_fifo_axis_tvalid;
-    assign post_fifo_axis_tready = m_axis_tready;
-    assign m_axis_tlast = post_fifo_axis_tlast;
-    assign m_axis_tid = post_fifo_axis_tid;
-    assign m_axis_tdest = post_fifo_axis_tdest;
-    assign m_axis_tuser = post_fifo_axis_tuser;
-
-end
-
-endgenerate
-
 endmodule
 
-`resetall
+`BSG_ABSTRACT_MODULE(axis_async_fifo_adapter)
diff --git a/lib/axis/rtl/axis_fifo.v b/lib/axis/rtl/axis_fifo.v
index acac04a..c9f233d 100644
--- a/lib/axis/rtl/axis_fifo.v
+++ b/lib/axis/rtl/axis_fifo.v
@@ -1,6 +1,6 @@
 /*
 
-Copyright (c) 2013-2023 Alex Forencich
+Copyright (c) 2013-2021 Alex Forencich
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -25,8 +25,6 @@ THE SOFTWARE.
 // Language: Verilog 2001
 
 `resetall
-`timescale 1ns / 1ps
-`default_nettype none
 
 /*
  * AXI4-Stream FIFO
@@ -58,11 +56,8 @@ module axis_fifo #
     parameter USER_ENABLE = 1,
     // tuser signal width
     parameter USER_WIDTH = 1,
-    // number of RAM pipeline registers
-    parameter RAM_PIPELINE = 1,
-    // use output FIFO
-    // When set, the RAM read enable and pipeline clock enables are removed
-    parameter OUTPUT_FIFO_ENABLE = 0,
+    // number of output pipeline registers
+    parameter PIPELINE_OUTPUT = 2,
     // Frame FIFO mode - operate on frames instead of cycles
     // When set, m_axis_tvalid will not be deasserted within a frame
     // Requires LAST_ENABLE set
@@ -80,15 +75,7 @@ module axis_fifo #
     // Drop incoming frames when full
     // When set, s_axis_tready is always asserted
     // Requires FRAME_FIFO and DROP_OVERSIZE_FRAME set
-    parameter DROP_WHEN_FULL = 0,
-    // Mark incoming frames as bad frames when full
-    // When set, s_axis_tready is always asserted
-    // Requires FRAME_FIFO to be clear
-    parameter MARK_WHEN_FULL = 0,
-    // Enable pause request input
-    parameter PAUSE_ENABLE = 0,
-    // Pause between frames
-    parameter FRAME_PAUSE = FRAME_FIFO
+    parameter DROP_WHEN_FULL = 0
 )
 (
     input  wire                   clk,
@@ -118,17 +105,9 @@ module axis_fifo #
     output wire [DEST_WIDTH-1:0]  m_axis_tdest,
     output wire [USER_WIDTH-1:0]  m_axis_tuser,
 
-    /*
-     * Pause
-     */
-    input  wire                   pause_req,
-    output wire                   pause_ack,
-
     /*
      * Status
      */
-    output wire [$clog2(DEPTH):0] status_depth,
-    output wire [$clog2(DEPTH):0] status_depth_commit,
     output wire                   status_overflow,
     output wire                   status_bad_frame,
     output wire                   status_good_frame
@@ -136,10 +115,13 @@ module axis_fifo #
 
 parameter ADDR_WIDTH = (KEEP_ENABLE && KEEP_WIDTH > 1) ? $clog2(DEPTH/KEEP_WIDTH) : $clog2(DEPTH);
 
-parameter OUTPUT_FIFO_ADDR_WIDTH = RAM_PIPELINE < 2 ? 3 : $clog2(RAM_PIPELINE*2+7);
-
 // check configuration
 initial begin
+    if (PIPELINE_OUTPUT < 1) begin
+        $error("Error: PIPELINE_OUTPUT must be at least 1 (instance %m)");
+        $finish;
+    end
+
     if (FRAME_FIFO && !LAST_ENABLE) begin
         $error("Error: FRAME_FIFO set requires LAST_ENABLE set (instance %m)");
         $finish;
@@ -160,20 +142,10 @@ initial begin
         $finish;
     end
 
-    if ((DROP_BAD_FRAME || MARK_WHEN_FULL) && (USER_BAD_FRAME_MASK & {USER_WIDTH{1'b1}}) == 0) begin
+    if (DROP_BAD_FRAME && (USER_BAD_FRAME_MASK & {USER_WIDTH{1'b1}}) == 0) begin
         $error("Error: Invalid USER_BAD_FRAME_MASK value (instance %m)");
         $finish;
     end
-
-    if (MARK_WHEN_FULL && FRAME_FIFO) begin
-        $error("Error: MARK_WHEN_FULL is not compatible with FRAME_FIFO (instance %m)");
-        $finish;
-    end
-
-    if (MARK_WHEN_FULL && !LAST_ENABLE) begin
-        $error("Error: MARK_WHEN_FULL set requires LAST_ENABLE set (instance %m)");
-        $finish;
-    end
 end
 
 localparam KEEP_OFFSET = DATA_WIDTH;
@@ -183,75 +155,56 @@ localparam DEST_OFFSET = ID_OFFSET   + (ID_ENABLE   ? ID_WIDTH   : 0);
 localparam USER_OFFSET = DEST_OFFSET + (DEST_ENABLE ? DEST_WIDTH : 0);
 localparam WIDTH       = USER_OFFSET + (USER_ENABLE ? USER_WIDTH : 0);
 
-reg [ADDR_WIDTH:0] wr_ptr_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] wr_ptr_commit_reg = {ADDR_WIDTH+1{1'b0}};
-reg [ADDR_WIDTH:0] rd_ptr_reg = {ADDR_WIDTH+1{1'b0}};
 
-(* ramstyle = "no_rw_check" *)
-reg [WIDTH-1:0] mem[(2**ADDR_WIDTH)-1:0];
-reg mem_read_data_valid_reg = 1'b0;
+reg [ADDR_WIDTH:0] wr_ptr_reg;
+reg [ADDR_WIDTH:0] wr_ptr_cur_reg;
+reg [ADDR_WIDTH:0] rd_ptr_reg;
+
+wire [WIDTH-1:0] s_axis;
+
+logic                  mem_w_v_li;
+logic [ADDR_WIDTH-1:0] mem_w_addr_li;
+wire [WIDTH-1:0]       mem_w_data_li = s_axis;
+logic                  mem_r_v_li;
+wire [ADDR_WIDTH-1:0]  mem_r_addr_li = rd_ptr_reg[ADDR_WIDTH-1:0];
+logic [WIDTH-1:0]      mem_r_data_lo;
 
-(* shreg_extract = "no" *)
-reg [WIDTH-1:0] m_axis_pipe_reg[RAM_PIPELINE+1-1:0];
-reg [RAM_PIPELINE+1-1:0] m_axis_tvalid_pipe_reg = 0;
+reg [PIPELINE_OUTPUT-1:0] m_axis_tvalid_pipe_reg;
 
 // full when first MSB different but rest same
 wire full = wr_ptr_reg == (rd_ptr_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});
+wire full_cur = wr_ptr_cur_reg == (rd_ptr_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});
 // empty when pointers match exactly
-wire empty = wr_ptr_commit_reg == rd_ptr_reg;
+wire empty = wr_ptr_reg == rd_ptr_reg;
 // overflow within packet
-wire full_wr = wr_ptr_reg == (wr_ptr_commit_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});
-
-reg s_frame_reg = 1'b0;
-
-reg drop_frame_reg = 1'b0;
-reg mark_frame_reg = 1'b0;
-reg send_frame_reg = 1'b0;
-reg [ADDR_WIDTH:0] depth_reg = 0;
-reg [ADDR_WIDTH:0] depth_commit_reg = 0;
-reg overflow_reg = 1'b0;
-reg bad_frame_reg = 1'b0;
-reg good_frame_reg = 1'b0;
+wire full_wr = wr_ptr_reg == (wr_ptr_cur_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});
 
-assign s_axis_tready = FRAME_FIFO ? (!full || (full_wr && DROP_OVERSIZE_FRAME) || DROP_WHEN_FULL) : (!full || MARK_WHEN_FULL);
+reg drop_frame_reg;
+reg send_frame_reg;
+reg overflow_reg;
+reg bad_frame_reg;
+reg good_frame_reg;
 
-wire [WIDTH-1:0] s_axis;
+assign s_axis_tready = FRAME_FIFO ? (!full_cur || (full_wr && DROP_OVERSIZE_FRAME) || DROP_WHEN_FULL) : !full;
 
 generate
     assign s_axis[DATA_WIDTH-1:0] = s_axis_tdata;
     if (KEEP_ENABLE) assign s_axis[KEEP_OFFSET +: KEEP_WIDTH] = s_axis_tkeep;
-    if (LAST_ENABLE) assign s_axis[LAST_OFFSET]               = s_axis_tlast | mark_frame_reg;
+    if (LAST_ENABLE) assign s_axis[LAST_OFFSET]               = s_axis_tlast;
     if (ID_ENABLE)   assign s_axis[ID_OFFSET   +: ID_WIDTH]   = s_axis_tid;
     if (DEST_ENABLE) assign s_axis[DEST_OFFSET +: DEST_WIDTH] = s_axis_tdest;
-    if (USER_ENABLE) assign s_axis[USER_OFFSET +: USER_WIDTH] = mark_frame_reg ? USER_BAD_FRAME_VALUE : s_axis_tuser;
+    if (USER_ENABLE) assign s_axis[USER_OFFSET +: USER_WIDTH] = s_axis_tuser;
 endgenerate
 
-wire [WIDTH-1:0] m_axis = m_axis_pipe_reg[RAM_PIPELINE+1-1];
-
-wire                   m_axis_tready_pipe;
-wire                   m_axis_tvalid_pipe = m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1];
-
-wire [DATA_WIDTH-1:0]  m_axis_tdata_pipe  = m_axis[DATA_WIDTH-1:0];
-wire [KEEP_WIDTH-1:0]  m_axis_tkeep_pipe  = KEEP_ENABLE ? m_axis[KEEP_OFFSET +: KEEP_WIDTH] : {KEEP_WIDTH{1'b1}};
-wire                   m_axis_tlast_pipe  = LAST_ENABLE ? m_axis[LAST_OFFSET] : 1'b1;
-wire [ID_WIDTH-1:0]    m_axis_tid_pipe    = ID_ENABLE   ? m_axis[ID_OFFSET +: ID_WIDTH] : {ID_WIDTH{1'b0}};
-wire [DEST_WIDTH-1:0]  m_axis_tdest_pipe  = DEST_ENABLE ? m_axis[DEST_OFFSET +: DEST_WIDTH] : {DEST_WIDTH{1'b0}};
-wire [USER_WIDTH-1:0]  m_axis_tuser_pipe  = USER_ENABLE ? m_axis[USER_OFFSET +: USER_WIDTH] : {USER_WIDTH{1'b0}};
-
-wire                   m_axis_tready_out;
-wire                   m_axis_tvalid_out;
+assign m_axis_tvalid = m_axis_tvalid_pipe_reg[PIPELINE_OUTPUT-1];
 
-wire [DATA_WIDTH-1:0]  m_axis_tdata_out;
-wire [KEEP_WIDTH-1:0]  m_axis_tkeep_out;
-wire                   m_axis_tlast_out;
-wire [ID_WIDTH-1:0]    m_axis_tid_out;
-wire [DEST_WIDTH-1:0]  m_axis_tdest_out;
-wire [USER_WIDTH-1:0]  m_axis_tuser_out;
+assign m_axis_tdata = mem_r_data_lo[DATA_WIDTH-1:0];
+assign m_axis_tkeep = KEEP_ENABLE ? mem_r_data_lo[KEEP_OFFSET +: KEEP_WIDTH] : {KEEP_WIDTH{1'b1}};
+assign m_axis_tlast = LAST_ENABLE ? mem_r_data_lo[LAST_OFFSET]               : 1'b1;
+assign m_axis_tid   = ID_ENABLE   ? mem_r_data_lo[ID_OFFSET   +: ID_WIDTH]   : {ID_WIDTH{1'b0}};
+assign m_axis_tdest = DEST_ENABLE ? mem_r_data_lo[DEST_OFFSET +: DEST_WIDTH] : {DEST_WIDTH{1'b0}};
+assign m_axis_tuser = USER_ENABLE ? mem_r_data_lo[USER_OFFSET +: USER_WIDTH] : {USER_WIDTH{1'b0}};
 
-wire pipe_ready;
-
-assign status_depth = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {depth_reg, {$clog2(KEEP_WIDTH){1'b0}}} : depth_reg;
-assign status_depth_commit = (KEEP_ENABLE && KEEP_WIDTH > 1) ? {depth_commit_reg, {$clog2(KEEP_WIDTH){1'b0}}} : depth_commit_reg;
 assign status_overflow = overflow_reg;
 assign status_bad_frame = bad_frame_reg;
 assign status_good_frame = good_frame_reg;
@@ -262,99 +215,50 @@ always @(posedge clk) begin
     bad_frame_reg <= 1'b0;
     good_frame_reg <= 1'b0;
 
-    if (s_axis_tready && s_axis_tvalid && LAST_ENABLE) begin
-        // track input frame status
-        s_frame_reg <= !s_axis_tlast;
-    end
-
-    if (FRAME_FIFO) begin
-        // frame FIFO mode
-        if (s_axis_tready && s_axis_tvalid) begin
-            // transfer in
-            if ((full && DROP_WHEN_FULL) || (full_wr && DROP_OVERSIZE_FRAME) || drop_frame_reg) begin
-                // full, packet overflow, or currently dropping frame
-                // drop frame
-                drop_frame_reg <= 1'b1;
-                if (s_axis_tlast) begin
-                    // end of frame, reset write pointer
-                    wr_ptr_reg <= wr_ptr_commit_reg;
-                    drop_frame_reg <= 1'b0;
-                    overflow_reg <= 1'b1;
-                end
-            end else begin
-                // store it
-                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-                wr_ptr_reg <= wr_ptr_reg + 1;
-                if (s_axis_tlast || (!DROP_OVERSIZE_FRAME && (full_wr || send_frame_reg))) begin
-                    // end of frame or send frame
-                    send_frame_reg <= !s_axis_tlast;
-                    if (s_axis_tlast && DROP_BAD_FRAME && USER_BAD_FRAME_MASK & ~(s_axis_tuser ^ USER_BAD_FRAME_VALUE)) begin
-                        // bad packet, reset write pointer
-                        wr_ptr_reg <= wr_ptr_commit_reg;
-                        bad_frame_reg <= 1'b1;
-                    end else begin
-                        // good packet or packet overflow, update write pointer
-                        wr_ptr_commit_reg <= wr_ptr_reg + 1;
-                        good_frame_reg <= s_axis_tlast;
-                    end
-                end
+    if (s_axis_tready && s_axis_tvalid) begin
+        // transfer in
+        if (!FRAME_FIFO) begin
+            // normal FIFO mode
+            wr_ptr_reg <= wr_ptr_reg + 1;
+        end else if ((full_cur && DROP_WHEN_FULL) || (full_wr && DROP_OVERSIZE_FRAME) || drop_frame_reg) begin
+            // full, packet overflow, or currently dropping frame
+            // drop frame
+            drop_frame_reg <= 1'b1;
+            if (s_axis_tlast) begin
+                // end of frame, reset write pointer
+                wr_ptr_cur_reg <= wr_ptr_reg;
+                drop_frame_reg <= 1'b0;
+                overflow_reg <= 1'b1;
             end
-        end else if (s_axis_tvalid && full_wr && !DROP_OVERSIZE_FRAME) begin
-            // data valid with packet overflow
-            // update write pointer
-            send_frame_reg <= 1'b1;
-            wr_ptr_commit_reg <= wr_ptr_reg;
-        end
-    end else begin
-        // normal FIFO mode
-        if (s_axis_tready && s_axis_tvalid) begin
-            if (drop_frame_reg && MARK_WHEN_FULL) begin
-                // currently dropping frame
-                if (s_axis_tlast) begin
-                    // end of frame
-                    if (!full && mark_frame_reg) begin
-                        // terminate marked frame
-                        mark_frame_reg <= 1'b0;
-                        mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-                        wr_ptr_reg <= wr_ptr_reg + 1;
-                        wr_ptr_commit_reg <= wr_ptr_reg + 1;
-                    end
-                    // end of frame, clear drop flag
-                    drop_frame_reg <= 1'b0;
-                    overflow_reg <= 1'b1;
-                end
-            end else if ((full || mark_frame_reg) && MARK_WHEN_FULL) begin
-                // full or marking frame
-                // drop frame; mark if this isn't the first cycle
-                drop_frame_reg <= 1'b1;
-                mark_frame_reg <= mark_frame_reg || s_frame_reg;
-                if (s_axis_tlast) begin
-                    drop_frame_reg <= 1'b0;
-                    overflow_reg <= 1'b1;
+        end else begin
+            // store it
+            wr_ptr_cur_reg <= wr_ptr_cur_reg + 1;
+            if (s_axis_tlast || (!DROP_OVERSIZE_FRAME && (full_wr || send_frame_reg))) begin
+                // end of frame or send frame
+                send_frame_reg <= !s_axis_tlast;
+                if (s_axis_tlast && DROP_BAD_FRAME && USER_BAD_FRAME_MASK & ~(s_axis_tuser ^ USER_BAD_FRAME_VALUE)) begin
+                    // bad packet, reset write pointer
+                    wr_ptr_cur_reg <= wr_ptr_reg;
+                    bad_frame_reg <= 1'b1;
+                end else begin
+                    // good packet or packet overflow, update write pointer
+                    wr_ptr_reg <= wr_ptr_cur_reg + 1;
+                    good_frame_reg <= s_axis_tlast;
                 end
-            end else begin
-                // transfer in
-                mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-                wr_ptr_reg <= wr_ptr_reg + 1;
-                wr_ptr_commit_reg <= wr_ptr_reg + 1;
             end
-        end else if ((!full && !drop_frame_reg && mark_frame_reg) && MARK_WHEN_FULL) begin
-            // terminate marked frame
-            mark_frame_reg <= 1'b0;
-            mem[wr_ptr_reg[ADDR_WIDTH-1:0]] <= s_axis;
-            wr_ptr_reg <= wr_ptr_reg + 1;
-            wr_ptr_commit_reg <= wr_ptr_reg + 1;
         end
+    end else if (s_axis_tvalid && full_wr && FRAME_FIFO && !DROP_OVERSIZE_FRAME) begin
+        // data valid with packet overflow
+        // update write pointer
+        send_frame_reg <= 1'b1;
+        wr_ptr_reg <= wr_ptr_cur_reg;
     end
 
     if (rst) begin
         wr_ptr_reg <= {ADDR_WIDTH+1{1'b0}};
-        wr_ptr_commit_reg <= {ADDR_WIDTH+1{1'b0}};
-
-        s_frame_reg <= 1'b0;
+        wr_ptr_cur_reg <= {ADDR_WIDTH+1{1'b0}};
 
         drop_frame_reg <= 1'b0;
-        mark_frame_reg <= 1'b0;
         send_frame_reg <= 1'b0;
         overflow_reg <= 1'b0;
         bad_frame_reg <= 1'b0;
@@ -362,35 +266,27 @@ always @(posedge clk) begin
     end
 end
 
-// Status
-always @(posedge clk) begin
-    depth_reg <= wr_ptr_reg - rd_ptr_reg;
-    depth_commit_reg <= wr_ptr_commit_reg - rd_ptr_reg;
-end
-
 // Read logic
 integer j;
 
 always @(posedge clk) begin
-    if (m_axis_tready_pipe) begin
+    if (m_axis_tready) begin
         // output ready; invalidate stage
-        m_axis_tvalid_pipe_reg[RAM_PIPELINE+1-1] <= 1'b0;
+        m_axis_tvalid_pipe_reg[PIPELINE_OUTPUT-1] <= 1'b0;
     end
 
-    for (j = RAM_PIPELINE+1-1; j > 0; j = j - 1) begin
-        if (m_axis_tready_pipe || ((~m_axis_tvalid_pipe_reg) >> j)) begin
+    for (j = PIPELINE_OUTPUT-1; j > 0; j = j - 1) begin
+        if (m_axis_tready || ((~m_axis_tvalid_pipe_reg) >> j)) begin
             // output ready or bubble in pipeline; transfer down pipeline
             m_axis_tvalid_pipe_reg[j] <= m_axis_tvalid_pipe_reg[j-1];
-            m_axis_pipe_reg[j] <= m_axis_pipe_reg[j-1];
             m_axis_tvalid_pipe_reg[j-1] <= 1'b0;
         end
     end
 
-    if (m_axis_tready_pipe || ~m_axis_tvalid_pipe_reg) begin
+    if (m_axis_tready || ~m_axis_tvalid_pipe_reg) begin
         // output ready or bubble in pipeline; read new data from FIFO
         m_axis_tvalid_pipe_reg[0] <= 1'b0;
-        m_axis_pipe_reg[0] <= mem[rd_ptr_reg[ADDR_WIDTH-1:0]];
-        if (!empty && pipe_ready) begin
+        if (!empty) begin
             // not empty, increment pointer
             m_axis_tvalid_pipe_reg[0] <= 1'b1;
             rd_ptr_reg <= rd_ptr_reg + 1;
@@ -399,166 +295,58 @@ always @(posedge clk) begin
 
     if (rst) begin
         rd_ptr_reg <= {ADDR_WIDTH+1{1'b0}};
-        m_axis_tvalid_pipe_reg <= 0;
+        m_axis_tvalid_pipe_reg <= {PIPELINE_OUTPUT{1'b0}};
     end
 end
 
-generate
-
-if (!OUTPUT_FIFO_ENABLE) begin
-
-    assign pipe_ready = 1'b1;
-
-    assign m_axis_tready_pipe = m_axis_tready_out;
-    assign m_axis_tvalid_out = m_axis_tvalid_pipe;
-
-    assign m_axis_tdata_out = m_axis_tdata_pipe;
-    assign m_axis_tkeep_out = m_axis_tkeep_pipe;
-    assign m_axis_tlast_out = m_axis_tlast_pipe;
-    assign m_axis_tid_out   = m_axis_tid_pipe;
-    assign m_axis_tdest_out = m_axis_tdest_pipe;
-    assign m_axis_tuser_out = m_axis_tuser_pipe;
-
-end else begin : output_fifo
-
-    // output datapath logic
-    reg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};
-    reg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};
-    reg                  m_axis_tvalid_reg = 1'b0;
-    reg                  m_axis_tlast_reg  = 1'b0;
-    reg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};
-    reg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};
-    reg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};
-
-    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_wr_ptr_reg = 0;
-    reg [OUTPUT_FIFO_ADDR_WIDTH+1-1:0] out_fifo_rd_ptr_reg = 0;
-    reg out_fifo_half_full_reg = 1'b0;
-
-    wire out_fifo_full = out_fifo_wr_ptr_reg == (out_fifo_rd_ptr_reg ^ {1'b1, {OUTPUT_FIFO_ADDR_WIDTH{1'b0}}});
-    wire out_fifo_empty = out_fifo_wr_ptr_reg == out_fifo_rd_ptr_reg;
-
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [DATA_WIDTH-1:0] out_fifo_tdata[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [KEEP_WIDTH-1:0] out_fifo_tkeep[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg                  out_fifo_tlast[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [ID_WIDTH-1:0]   out_fifo_tid[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [DEST_WIDTH-1:0] out_fifo_tdest[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-    (* ram_style = "distributed", ramstyle = "no_rw_check, mlab" *)
-    reg [USER_WIDTH-1:0] out_fifo_tuser[2**OUTPUT_FIFO_ADDR_WIDTH-1:0];
-
-    assign pipe_ready = !out_fifo_half_full_reg;
-
-    assign m_axis_tready_pipe = 1'b1;
-
-    assign m_axis_tdata_out  = m_axis_tdata_reg;
-    assign m_axis_tkeep_out  = KEEP_ENABLE ? m_axis_tkeep_reg : {KEEP_WIDTH{1'b1}};
-    assign m_axis_tvalid_out = m_axis_tvalid_reg;
-    assign m_axis_tlast_out  = LAST_ENABLE ? m_axis_tlast_reg : 1'b1;
-    assign m_axis_tid_out    = ID_ENABLE   ? m_axis_tid_reg   : {ID_WIDTH{1'b0}};
-    assign m_axis_tdest_out  = DEST_ENABLE ? m_axis_tdest_reg : {DEST_WIDTH{1'b0}};
-    assign m_axis_tuser_out  = USER_ENABLE ? m_axis_tuser_reg : {USER_WIDTH{1'b0}};
-
-    always @(posedge clk) begin
-        m_axis_tvalid_reg <= m_axis_tvalid_reg && !m_axis_tready_out;
-
-        out_fifo_half_full_reg <= $unsigned(out_fifo_wr_ptr_reg - out_fifo_rd_ptr_reg) >= 2**(OUTPUT_FIFO_ADDR_WIDTH-1);
-
-        if (!out_fifo_full && m_axis_tvalid_pipe) begin
-            out_fifo_tdata[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdata_pipe;
-            out_fifo_tkeep[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tkeep_pipe;
-            out_fifo_tlast[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tlast_pipe;
-            out_fifo_tid[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tid_pipe;
-            out_fifo_tdest[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tdest_pipe;
-            out_fifo_tuser[out_fifo_wr_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]] <= m_axis_tuser_pipe;
-            out_fifo_wr_ptr_reg <= out_fifo_wr_ptr_reg + 1;
-        end
-
-        if (!out_fifo_empty && (!m_axis_tvalid_reg || m_axis_tready_out)) begin
-            m_axis_tdata_reg <= out_fifo_tdata[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tkeep_reg <= out_fifo_tkeep[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tvalid_reg <= 1'b1;
-            m_axis_tlast_reg <= out_fifo_tlast[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tid_reg <= out_fifo_tid[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tdest_reg <= out_fifo_tdest[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            m_axis_tuser_reg <= out_fifo_tuser[out_fifo_rd_ptr_reg[OUTPUT_FIFO_ADDR_WIDTH-1:0]];
-            out_fifo_rd_ptr_reg <= out_fifo_rd_ptr_reg + 1;
-        end
-
-        if (rst) begin
-            out_fifo_wr_ptr_reg <= 0;
-            out_fifo_rd_ptr_reg <= 0;
-            m_axis_tvalid_reg <= 1'b0;
+//Write logic
+always @(*) begin
+    mem_w_addr_li = '0;
+    mem_w_v_li = 1'b0;
+    if (s_axis_tready && s_axis_tvalid) begin
+        // transfer in
+        if (!FRAME_FIFO) begin
+            // normal FIFO mode
+            mem_w_addr_li = wr_ptr_reg[ADDR_WIDTH-1:0];
+            mem_w_v_li = 1'b1;
+        end else if ((full_cur && DROP_WHEN_FULL) || (full_wr && DROP_OVERSIZE_FRAME) || drop_frame_reg) begin
+        end else begin
+            // store it
+            mem_w_addr_li = wr_ptr_cur_reg[ADDR_WIDTH-1:0];
+            mem_w_v_li = 1'b1;
         end
     end
-
 end
 
-if (PAUSE_ENABLE) begin : pause
-
-    // Pause logic
-    reg pause_reg = 1'b0;
-    reg pause_frame_reg = 1'b0;
-
-    assign m_axis_tready_out = m_axis_tready && !pause_reg;
-    assign m_axis_tvalid = m_axis_tvalid_out && !pause_reg;
-
-    assign m_axis_tdata = m_axis_tdata_out;
-    assign m_axis_tkeep = m_axis_tkeep_out;
-    assign m_axis_tlast = m_axis_tlast_out;
-    assign m_axis_tid   = m_axis_tid_out;
-    assign m_axis_tdest = m_axis_tdest_out;
-    assign m_axis_tuser = m_axis_tuser_out;
-
-    assign pause_ack = pause_reg;
-
-    always @(posedge clk) begin
-        if (FRAME_PAUSE) begin
-            if (pause_reg) begin
-                // paused; update pause status
-                pause_reg <= pause_req;
-            end else if (m_axis_tvalid_out) begin
-                // frame transfer; set frame bit
-                pause_frame_reg <= 1'b1;
-                if (m_axis_tready && m_axis_tlast) begin
-                    // end of frame; clear frame bit and update pause status
-                    pause_frame_reg <= 1'b0;
-                    pause_reg <= pause_req;
-                end
-            end else if (!pause_frame_reg) begin
-                // idle; update pause status
-                pause_reg <= pause_req;
-            end
-        end else begin
-            pause_reg <= pause_req;
-        end
-
-        if (rst) begin
-            pause_frame_reg <= 1'b0;
-            pause_reg <= 1'b0;
+// Read logic
+always @(*) begin
+    mem_r_v_li = 1'b0;
+    if (m_axis_tready || ~m_axis_tvalid_pipe_reg) begin
+        // output ready or bubble in pipeline; read new data from FIFO
+        if (!empty) begin
+            mem_r_v_li = 1'b1;
         end
     end
-
-end else begin
-
-    assign m_axis_tready_out = m_axis_tready;
-    assign m_axis_tvalid = m_axis_tvalid_out;
-
-    assign m_axis_tdata = m_axis_tdata_out;
-    assign m_axis_tkeep = m_axis_tkeep_out;
-    assign m_axis_tlast = m_axis_tlast_out;
-    assign m_axis_tid   = m_axis_tid_out;
-    assign m_axis_tdest = m_axis_tdest_out;
-    assign m_axis_tuser = m_axis_tuser_out;
-
-    assign pause_ack = 1'b0;
-
 end
 
-endgenerate
+
+axis_fifo_mem #(
+    .width_p(WIDTH)
+   ,.els_p(2**ADDR_WIDTH)
+   ,.pipeline_output_p(PIPELINE_OUTPUT)
+) mem (
+    .clk_i(clk)
+   ,.reset_i(rst)
+   ,.w_v_i   (mem_w_v_li)
+   ,.w_addr_i(mem_w_addr_li)
+   ,.w_data_i(mem_w_data_li)
+   ,.r_v_i   (mem_r_v_li)
+   ,.r_addr_i(mem_r_addr_li)
+   ,.r_data_o(mem_r_data_lo)
+
+   ,.output_ready_i(m_axis_tready)
+   ,.valid_pipe_reg_i(m_axis_tvalid_pipe_reg)
+);
 
 endmodule
 
diff --git a/rtl/axis_gmii_rx.v b/rtl/axis_gmii_rx.v
index 9b4f30d..795ae8c 100644
--- a/rtl/axis_gmii_rx.v
+++ b/rtl/axis_gmii_rx.v
@@ -24,10 +24,6 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * AXI4-Stream GMII frame receiver (GMII in, AXI out)
  */
@@ -68,11 +64,6 @@ module axis_gmii_rx #
     input  wire                     clk_enable,
     input  wire                     mii_select,
 
-    /*
-     * Configuration
-     */
-    input  wire                     cfg_rx_enable,
-
     /*
      * Status
      */
@@ -98,52 +89,55 @@ localparam [2:0]
     STATE_PAYLOAD = 3'd1,
     STATE_WAIT_LAST = 3'd2;
 
-reg [2:0] state_reg = STATE_IDLE, state_next;
+reg [2:0] state_reg, state_next;
 
 // datapath control signals
 reg reset_crc;
 reg update_crc;
 
-reg mii_odd = 1'b0;
-reg in_frame = 1'b0;
+reg mii_odd;
+reg mii_locked;
 
-reg [DATA_WIDTH-1:0] gmii_rxd_d0 = {DATA_WIDTH{1'b0}};
-reg [DATA_WIDTH-1:0] gmii_rxd_d1 = {DATA_WIDTH{1'b0}};
-reg [DATA_WIDTH-1:0] gmii_rxd_d2 = {DATA_WIDTH{1'b0}};
-reg [DATA_WIDTH-1:0] gmii_rxd_d3 = {DATA_WIDTH{1'b0}};
-reg [DATA_WIDTH-1:0] gmii_rxd_d4 = {DATA_WIDTH{1'b0}};
+reg [DATA_WIDTH-1:0] gmii_rxd_d0;
+reg [DATA_WIDTH-1:0] gmii_rxd_d1;
+reg [DATA_WIDTH-1:0] gmii_rxd_d2;
+reg [DATA_WIDTH-1:0] gmii_rxd_d3;
+reg [DATA_WIDTH-1:0] gmii_rxd_d4;
 
-reg gmii_rx_dv_d0 = 1'b0;
-reg gmii_rx_dv_d1 = 1'b0;
-reg gmii_rx_dv_d2 = 1'b0;
-reg gmii_rx_dv_d3 = 1'b0;
-reg gmii_rx_dv_d4 = 1'b0;
+reg gmii_rx_dv_d0;
+reg gmii_rx_dv_d1;
+reg gmii_rx_dv_d2;
+reg gmii_rx_dv_d3;
+reg gmii_rx_dv_d4;
 
-reg gmii_rx_er_d0 = 1'b0;
-reg gmii_rx_er_d1 = 1'b0;
-reg gmii_rx_er_d2 = 1'b0;
-reg gmii_rx_er_d3 = 1'b0;
-reg gmii_rx_er_d4 = 1'b0;
+reg gmii_rx_er_d0;
+reg gmii_rx_er_d1;
+reg gmii_rx_er_d2;
+reg gmii_rx_er_d3;
+reg gmii_rx_er_d4;
 
-reg [DATA_WIDTH-1:0] m_axis_tdata_reg = {DATA_WIDTH{1'b0}}, m_axis_tdata_next;
-reg m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;
-reg m_axis_tlast_reg = 1'b0, m_axis_tlast_next;
-reg m_axis_tuser_reg = 1'b0, m_axis_tuser_next;
+reg [DATA_WIDTH-1:0] m_axis_tdata_reg, m_axis_tdata_next;
+reg m_axis_tvalid_reg, m_axis_tvalid_next;
+reg m_axis_tlast_reg, m_axis_tlast_next;
+reg m_axis_tuser_reg, m_axis_tuser_next;
 
-reg start_packet_int_reg = 1'b0;
-reg start_packet_reg = 1'b0;
-reg error_bad_frame_reg = 1'b0, error_bad_frame_next;
-reg error_bad_fcs_reg = 1'b0, error_bad_fcs_next;
+reg start_packet_reg, start_packet_next;
+reg error_bad_frame_reg, error_bad_frame_next;
+reg error_bad_fcs_reg, error_bad_fcs_next;
 
-reg [PTP_TS_WIDTH-1:0] ptp_ts_reg = 0;
+reg [PTP_TS_WIDTH-1:0] ptp_ts_reg, ptp_ts_next;
 
-reg [31:0] crc_state = 32'hFFFFFFFF;
+reg [31:0] crc_state;
 wire [31:0] crc_next;
 
 assign m_axis_tdata = m_axis_tdata_reg;
 assign m_axis_tvalid = m_axis_tvalid_reg;
 assign m_axis_tlast = m_axis_tlast_reg;
-assign m_axis_tuser = PTP_TS_ENABLE ? {ptp_ts_reg, m_axis_tuser_reg} : m_axis_tuser_reg;
+
+if(PTP_TS_ENABLE)
+  assign m_axis_tuser = {ptp_ts_reg, m_axis_tuser_reg};
+else
+  assign m_axis_tuser = m_axis_tuser_reg;
 
 assign start_packet = start_packet_reg;
 assign error_bad_frame = error_bad_frame_reg;
@@ -176,9 +170,12 @@ always @* begin
     m_axis_tlast_next = 1'b0;
     m_axis_tuser_next = 1'b0;
 
+    start_packet_next = 1'b0;
     error_bad_frame_next = 1'b0;
     error_bad_fcs_next = 1'b0;
 
+    ptp_ts_next = ptp_ts_reg;
+
     if (!clk_enable) begin
         // clock disabled - hold state
         state_next = state_reg;
@@ -191,7 +188,9 @@ always @* begin
                 // idle state - wait for packet
                 reset_crc = 1'b1;
 
-                if (gmii_rx_dv_d4 && !gmii_rx_er_d4 && gmii_rxd_d4 == ETH_SFD && cfg_rx_enable) begin
+                if (gmii_rx_dv_d4 && !gmii_rx_er_d4 && gmii_rxd_d4 == ETH_SFD) begin
+                    ptp_ts_next = ptp_ts;
+                    start_packet_next = 1'b1;
                     state_next = STATE_PAYLOAD;
                 end else begin
                     state_next = STATE_IDLE;
@@ -247,28 +246,21 @@ end
 always @(posedge clk) begin
     state_reg <= state_next;
 
+    ptp_ts_reg <= ptp_ts_next;
+
     m_axis_tdata_reg <= m_axis_tdata_next;
     m_axis_tvalid_reg <= m_axis_tvalid_next;
     m_axis_tlast_reg <= m_axis_tlast_next;
     m_axis_tuser_reg <= m_axis_tuser_next;
 
-    start_packet_int_reg <= 1'b0;
-    start_packet_reg <= 1'b0;
-
-    if (start_packet_int_reg) begin
-        ptp_ts_reg <= ptp_ts;
-        start_packet_reg <= 1'b1;
-    end
-
     if (clk_enable) begin
         if (mii_select) begin
             mii_odd <= !mii_odd;
 
-            if (in_frame) begin
-                in_frame <= gmii_rx_dv;
+            if (mii_locked) begin
+                mii_locked <= gmii_rx_dv;
             end else if (gmii_rx_dv && {gmii_rxd[3:0], gmii_rxd_d0[7:4]} == ETH_SFD) begin
-                in_frame <= 1'b1;
-                start_packet_int_reg <= 1'b1;
+                mii_locked <= 1'b1;
                 mii_odd <= 1'b1;
             end
 
@@ -296,13 +288,6 @@ always @(posedge clk) begin
                 gmii_rx_er_d0 <= gmii_rx_er;
             end
         end else begin
-            if (in_frame) begin
-                in_frame <= gmii_rx_dv;
-            end else if (gmii_rx_dv && gmii_rxd == ETH_SFD) begin
-                in_frame <= 1'b1;
-                start_packet_int_reg <= 1'b1;
-            end
-
             gmii_rxd_d0 <= gmii_rxd;
             gmii_rxd_d1 <= gmii_rxd_d0;
             gmii_rxd_d2 <= gmii_rxd_d1;
@@ -329,20 +314,29 @@ always @(posedge clk) begin
         crc_state <= crc_next;
     end
 
+    start_packet_reg <= start_packet_next;
     error_bad_frame_reg <= error_bad_frame_next;
     error_bad_fcs_reg <= error_bad_fcs_next;
 
     if (rst) begin
+        gmii_rxd_d0 <= {DATA_WIDTH{1'b0}};
+        gmii_rxd_d1 <= {DATA_WIDTH{1'b0}};
+        gmii_rxd_d2 <= {DATA_WIDTH{1'b0}};
+        gmii_rxd_d3 <= {DATA_WIDTH{1'b0}};
+        gmii_rxd_d4 <= {DATA_WIDTH{1'b0}};
+        ptp_ts_reg <= '0;
+
         state_reg <= STATE_IDLE;
 
         m_axis_tvalid_reg <= 1'b0;
 
-        start_packet_int_reg <= 1'b0;
         start_packet_reg <= 1'b0;
         error_bad_frame_reg <= 1'b0;
         error_bad_fcs_reg <= 1'b0;
 
-        in_frame <= 1'b0;
+        crc_state <= 32'hFFFFFFFF;
+
+        mii_locked <= 1'b0;
         mii_odd <= 1'b0;
 
         gmii_rx_dv_d0 <= 1'b0;
@@ -354,5 +348,3 @@ always @(posedge clk) begin
 end
 
 endmodule
-
-`resetall
diff --git a/rtl/axis_gmii_tx.v b/rtl/axis_gmii_tx.v
index 1104718..25336d0 100644
--- a/rtl/axis_gmii_tx.v
+++ b/rtl/axis_gmii_tx.v
@@ -24,10 +24,6 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * AXI4-Stream GMII frame transmitter (AXI in, GMII out)
  */
@@ -38,10 +34,9 @@ module axis_gmii_tx #
     parameter MIN_FRAME_LENGTH = 64,
     parameter PTP_TS_ENABLE = 0,
     parameter PTP_TS_WIDTH = 96,
-    parameter PTP_TS_CTRL_IN_TUSER = 0,
     parameter PTP_TAG_ENABLE = PTP_TS_ENABLE,
     parameter PTP_TAG_WIDTH = 16,
-    parameter USER_WIDTH = (PTP_TS_ENABLE ? (PTP_TAG_ENABLE ? PTP_TAG_WIDTH : 0) + (PTP_TS_CTRL_IN_TUSER ? 1 : 0) : 0) + 1
+    parameter USER_WIDTH = (PTP_TAG_ENABLE ? PTP_TAG_WIDTH : 0) + 1
 )
 (
     input  wire                      clk,
@@ -80,8 +75,7 @@ module axis_gmii_tx #
     /*
      * Configuration
      */
-    input  wire [7:0]                cfg_ifg,
-    input  wire                      cfg_tx_enable,
+    input  wire [7:0]                ifg_delay,
 
     /*
      * Status
@@ -90,8 +84,6 @@ module axis_gmii_tx #
     output wire                      error_underflow
 );
 
-parameter MIN_LEN_WIDTH = $clog2(MIN_FRAME_LENGTH-4-1+1);
-
 // bus width assertions
 initial begin
     if (DATA_WIDTH != 8) begin
@@ -111,39 +103,36 @@ localparam [2:0]
     STATE_LAST = 3'd3,
     STATE_PAD = 3'd4,
     STATE_FCS = 3'd5,
-    STATE_IFG = 3'd6;
+    STATE_WAIT_END = 3'd6,
+    STATE_IFG = 3'd7;
 
-reg [2:0] state_reg = STATE_IDLE, state_next;
+reg [2:0] state_reg, state_next;
 
 // datapath control signals
 reg reset_crc;
 reg update_crc;
 
-reg [7:0] s_tdata_reg = 8'd0, s_tdata_next;
+reg [7:0] s_tdata_reg, s_tdata_next;
 
-reg mii_odd_reg = 1'b0, mii_odd_next;
-reg [3:0] mii_msn_reg = 4'b0, mii_msn_next;
+reg mii_odd_reg, mii_odd_next;
+reg [3:0] mii_msn_reg, mii_msn_next;
 
-reg frame_reg = 1'b0, frame_next;
-reg frame_error_reg = 1'b0, frame_error_next;
-reg [7:0] frame_ptr_reg = 0, frame_ptr_next;
-reg [MIN_LEN_WIDTH-1:0] frame_min_count_reg = 0, frame_min_count_next;
+reg [15:0] frame_ptr_reg, frame_ptr_next;
 
-reg [7:0] gmii_txd_reg = 8'd0, gmii_txd_next;
-reg gmii_tx_en_reg = 1'b0, gmii_tx_en_next;
-reg gmii_tx_er_reg = 1'b0, gmii_tx_er_next;
+reg [7:0] gmii_txd_reg, gmii_txd_next;
+reg gmii_tx_en_reg, gmii_tx_en_next;
+reg gmii_tx_er_reg, gmii_tx_er_next;
 
-reg s_axis_tready_reg = 1'b0, s_axis_tready_next;
+reg s_axis_tready_reg, s_axis_tready_next;
 
-reg [PTP_TS_WIDTH-1:0] m_axis_ptp_ts_reg = 0, m_axis_ptp_ts_next;
-reg [PTP_TAG_WIDTH-1:0] m_axis_ptp_ts_tag_reg = 0, m_axis_ptp_ts_tag_next;
-reg m_axis_ptp_ts_valid_reg = 1'b0, m_axis_ptp_ts_valid_next;
+reg [PTP_TS_WIDTH-1:0] m_axis_ptp_ts_reg, m_axis_ptp_ts_next;
+reg [PTP_TAG_WIDTH-1:0] m_axis_ptp_ts_tag_reg, m_axis_ptp_ts_tag_next;
+reg m_axis_ptp_ts_valid_reg, m_axis_ptp_ts_valid_next;
 
-reg start_packet_int_reg = 1'b0, start_packet_int_next;
-reg start_packet_reg = 1'b0, start_packet_next;
-reg error_underflow_reg = 1'b0, error_underflow_next;
+reg start_packet_reg, start_packet_next;
+reg error_underflow_reg, error_underflow_next;
 
-reg [31:0] crc_state = 32'hFFFFFFFF;
+reg [31:0] crc_state;
 wire [31:0] crc_next;
 
 assign s_axis_tready = s_axis_tready_reg;
@@ -152,8 +141,8 @@ assign gmii_txd = gmii_txd_reg;
 assign gmii_tx_en = gmii_tx_en_reg;
 assign gmii_tx_er = gmii_tx_er_reg;
 
-assign m_axis_ptp_ts = PTP_TS_ENABLE ? m_axis_ptp_ts_reg : 0;
-assign m_axis_ptp_ts_tag = PTP_TAG_ENABLE ? m_axis_ptp_ts_tag_reg : 0;
+assign m_axis_ptp_ts = PTP_TS_ENABLE ? m_axis_ptp_ts_reg : {PTP_TS_WIDTH{1'b0}};
+assign m_axis_ptp_ts_tag = PTP_TAG_ENABLE ? m_axis_ptp_ts_tag_reg : {PTP_TAG_WIDTH{1'b0}};
 assign m_axis_ptp_ts_valid = PTP_TS_ENABLE || PTP_TAG_ENABLE ? m_axis_ptp_ts_valid_reg : 1'b0;
 
 assign start_packet = start_packet_reg;
@@ -184,10 +173,7 @@ always @* begin
     mii_odd_next = mii_odd_reg;
     mii_msn_next = mii_msn_reg;
 
-    frame_next = frame_reg;
-    frame_error_next = frame_error_reg;
     frame_ptr_next = frame_ptr_reg;
-    frame_min_count_next = frame_min_count_reg;
 
     s_axis_tready_next = 1'b0;
 
@@ -197,29 +183,13 @@ always @* begin
     m_axis_ptp_ts_tag_next = m_axis_ptp_ts_tag_reg;
     m_axis_ptp_ts_valid_next = 1'b0;
 
-    if (start_packet_reg && PTP_TS_ENABLE) begin
-        m_axis_ptp_ts_next = ptp_ts;
-        if (PTP_TS_CTRL_IN_TUSER) begin
-            m_axis_ptp_ts_tag_next = s_axis_tuser >> 2;
-            m_axis_ptp_ts_valid_next = s_axis_tuser[1];
-        end else begin
-            m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;
-            m_axis_ptp_ts_valid_next = 1'b1;
-        end
-    end
-
     gmii_txd_next = {DATA_WIDTH{1'b0}};
     gmii_tx_en_next = 1'b0;
     gmii_tx_er_next = 1'b0;
 
-    start_packet_int_next = start_packet_int_reg;
     start_packet_next = 1'b0;
     error_underflow_next = 1'b0;
 
-    if (s_axis_tvalid && s_axis_tready) begin
-        frame_next = !s_axis_tlast;
-    end
-
     if (!clk_enable) begin
         // clock disabled - hold state and outputs
         gmii_txd_next = gmii_txd_reg;
@@ -233,24 +203,16 @@ always @* begin
         gmii_tx_en_next = gmii_tx_en_reg;
         gmii_tx_er_next = gmii_tx_er_reg;
         state_next = state_reg;
-        if (start_packet_int_reg) begin
-            start_packet_int_next = 1'b0;
-            start_packet_next = 1'b1;
-        end
     end else begin
         case (state_reg)
             STATE_IDLE: begin
                 // idle state - wait for packet
                 reset_crc = 1'b1;
-
                 mii_odd_next = 1'b0;
-                frame_ptr_next = 1;
 
-                frame_error_next = 1'b0;
-                frame_min_count_next = MIN_FRAME_LENGTH-4-1;
-
-                if (s_axis_tvalid && cfg_tx_enable) begin
+                if (s_axis_tvalid) begin
                     mii_odd_next = 1'b1;
+                    frame_ptr_next = 16'd1;
                     gmii_txd_next = ETH_PRE;
                     gmii_tx_en_next = 1'b1;
                     state_next = STATE_PREAMBLE;
@@ -263,28 +225,27 @@ always @* begin
                 reset_crc = 1'b1;
 
                 mii_odd_next = 1'b1;
-                frame_ptr_next = frame_ptr_reg + 1;
+                frame_ptr_next = frame_ptr_reg + 16'd1;
 
                 gmii_txd_next = ETH_PRE;
                 gmii_tx_en_next = 1'b1;
 
-                if (frame_ptr_reg == 6) begin
+                if (frame_ptr_reg == 16'd6) begin
                     s_axis_tready_next = 1'b1;
                     s_tdata_next = s_axis_tdata;
                     state_next = STATE_PREAMBLE;
-                end else if (frame_ptr_reg == 7) begin
+                end else if (frame_ptr_reg == 16'd7) begin
                     // end of preamble; start payload
-                    frame_ptr_next = 0;
+                    frame_ptr_next = 16'd0;
                     if (s_axis_tready_reg) begin
                         s_axis_tready_next = 1'b1;
                         s_tdata_next = s_axis_tdata;
                     end
                     gmii_txd_next = ETH_SFD;
-                    if (mii_select) begin
-                        start_packet_int_next = 1'b1;
-                    end else begin
-                        start_packet_next = 1'b1;
-                    end
+                    m_axis_ptp_ts_next = ptp_ts;
+                    m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;
+                    m_axis_ptp_ts_valid_next = 1'b1;
+                    start_packet_next = 1'b1;
                     state_next = STATE_PAYLOAD;
                 end else begin
                     state_next = STATE_PREAMBLE;
@@ -297,72 +258,77 @@ always @* begin
                 s_axis_tready_next = 1'b1;
 
                 mii_odd_next = 1'b1;
-
-                if (frame_min_count_reg) begin
-                    frame_min_count_next = frame_min_count_reg - 1;
-                end
+                frame_ptr_next = frame_ptr_reg + 16'd1;
 
                 gmii_txd_next = s_tdata_reg;
                 gmii_tx_en_next = 1'b1;
 
                 s_tdata_next = s_axis_tdata;
 
-                if (!s_axis_tvalid || s_axis_tlast) begin
-                    s_axis_tready_next = frame_next; // drop frame
-                    frame_error_next = !s_axis_tvalid || s_axis_tuser[0];
-                    error_underflow_next = !s_axis_tvalid;
-
-                    state_next = STATE_LAST;
+                if (s_axis_tvalid) begin
+                    if (s_axis_tlast) begin
+                        s_axis_tready_next = !s_axis_tready_reg;
+                        if (s_axis_tuser[0]) begin
+                            gmii_tx_er_next = 1'b1;
+                            frame_ptr_next = 1'b0;
+                            state_next = STATE_IFG;
+                        end else begin
+                            state_next = STATE_LAST;
+                        end
+                    end else begin
+                        state_next = STATE_PAYLOAD;
+                    end
                 end else begin
-                    state_next = STATE_PAYLOAD;
+                    // tvalid deassert, fail frame
+                    gmii_tx_er_next = 1'b1;
+                    frame_ptr_next = 16'd0;
+                    error_underflow_next = 1'b1;
+                    state_next = STATE_WAIT_END;
                 end
             end
             STATE_LAST: begin
                 // last payload word
 
                 update_crc = 1'b1;
-                s_axis_tready_next = 1'b0;
 
                 mii_odd_next = 1'b1;
+                frame_ptr_next = frame_ptr_reg + 16'd1;
 
                 gmii_txd_next = s_tdata_reg;
                 gmii_tx_en_next = 1'b1;
 
-                if (ENABLE_PADDING && frame_min_count_reg) begin
-                    frame_min_count_next = frame_min_count_reg - 1;
+                if (ENABLE_PADDING && frame_ptr_reg < MIN_FRAME_LENGTH-5) begin
                     s_tdata_next = 8'd0;
                     state_next = STATE_PAD;
                 end else begin
-                    frame_ptr_next = 0;
+                    frame_ptr_next = 16'd0;
                     state_next = STATE_FCS;
                 end
             end
             STATE_PAD: begin
                 // send padding
-                s_axis_tready_next = frame_next; // drop frame
 
                 update_crc = 1'b1;
                 mii_odd_next = 1'b1;
+                frame_ptr_next = frame_ptr_reg + 16'd1;
 
                 gmii_txd_next = 8'd0;
                 gmii_tx_en_next = 1'b1;
 
                 s_tdata_next = 8'd0;
 
-                if (frame_min_count_reg) begin
-                    frame_min_count_next = frame_min_count_reg - 1;
+                if (frame_ptr_reg < MIN_FRAME_LENGTH-5) begin
                     state_next = STATE_PAD;
                 end else begin
-                    frame_ptr_next = 0;
+                    frame_ptr_next = 16'd0;
                     state_next = STATE_FCS;
                 end
             end
             STATE_FCS: begin
                 // send FCS
-                s_axis_tready_next = frame_next; // drop frame
 
                 mii_odd_next = 1'b1;
-                frame_ptr_next = frame_ptr_reg + 1;
+                frame_ptr_next = frame_ptr_reg + 16'd1;
 
                 case (frame_ptr_reg)
                     2'd0: gmii_txd_next = ~crc_state[7:0];
@@ -371,23 +337,47 @@ always @* begin
                     2'd3: gmii_txd_next = ~crc_state[31:24];
                 endcase
                 gmii_tx_en_next = 1'b1;
-                gmii_tx_er_next = frame_error_reg;
 
                 if (frame_ptr_reg < 3) begin
                     state_next = STATE_FCS;
                 end else begin
-                    frame_ptr_next = 0;
+                    frame_ptr_next = 16'd0;
                     state_next = STATE_IFG;
                 end
             end
+            STATE_WAIT_END: begin
+                // wait for end of frame
+
+                reset_crc = 1'b1;
+
+                mii_odd_next = 1'b1;
+                frame_ptr_next = frame_ptr_reg + 16'd1;
+                s_axis_tready_next = 1'b1;
+
+                if (s_axis_tvalid) begin
+                    if (s_axis_tlast) begin
+                        s_axis_tready_next = 1'b0;
+                        if (frame_ptr_reg < ifg_delay-1) begin
+                            state_next = STATE_IFG;
+                        end else begin
+                            state_next = STATE_IDLE;
+                        end
+                    end else begin
+                        state_next = STATE_WAIT_END;
+                    end
+                end else begin
+                    state_next = STATE_WAIT_END;
+                end
+            end
             STATE_IFG: begin
                 // send IFG
-                s_axis_tready_next = frame_next; // drop frame
+
+                reset_crc = 1'b1;
 
                 mii_odd_next = 1'b1;
-                frame_ptr_next = frame_ptr_reg + 1;
+                frame_ptr_next = frame_ptr_reg + 16'd1;
 
-                if (frame_ptr_reg < cfg_ifg-1 || frame_reg) begin
+                if (frame_ptr_reg < ifg_delay-1) begin
                     state_next = STATE_IFG;
                 end else begin
                     state_next = STATE_IDLE;
@@ -405,10 +395,7 @@ end
 always @(posedge clk) begin
     state_reg <= state_next;
 
-    frame_reg <= frame_next;
-    frame_error_reg <= frame_error_next;
     frame_ptr_reg <= frame_ptr_next;
-    frame_min_count_reg <= frame_min_count_next;
 
     m_axis_ptp_ts_reg <= m_axis_ptp_ts_next;
     m_axis_ptp_ts_tag_reg <= m_axis_ptp_ts_tag_next;
@@ -431,14 +418,19 @@ always @(posedge clk) begin
         crc_state <= crc_next;
     end
 
-    start_packet_int_reg <= start_packet_int_next;
     start_packet_reg <= start_packet_next;
     error_underflow_reg <= error_underflow_next;
 
     if (rst) begin
+        s_tdata_reg <= 8'd0;
+        mii_odd_reg <= 1'b0;
+        mii_msn_reg <= 4'b0;
+        m_axis_ptp_ts_reg <= '0;
+        m_axis_ptp_ts_tag_reg <= '0;
+
         state_reg <= STATE_IDLE;
 
-        frame_reg <= 1'b0;
+        frame_ptr_reg <= 16'd0;
 
         s_axis_tready_reg <= 1'b0;
 
@@ -447,12 +439,11 @@ always @(posedge clk) begin
         gmii_tx_en_reg <= 1'b0;
         gmii_tx_er_reg <= 1'b0;
 
-        start_packet_int_reg <= 1'b0;
         start_packet_reg <= 1'b0;
         error_underflow_reg <= 1'b0;
+
+        crc_state <= 32'hFFFFFFFF;
     end
 end
 
 endmodule
-
-`resetall
diff --git a/rtl/eth_mac_1g.v b/rtl/eth_mac_1g.v
index 0e1b9a1..98a7b95 100644
--- a/rtl/eth_mac_1g.v
+++ b/rtl/eth_mac_1g.v
@@ -1,6 +1,6 @@
 /*
 
-Copyright (c) 2015-2023 Alex Forencich
+Copyright (c) 2015-2018 Alex Forencich
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -24,10 +24,6 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * 1G Ethernet MAC
  */
@@ -36,16 +32,14 @@ module eth_mac_1g #
     parameter DATA_WIDTH = 8,
     parameter ENABLE_PADDING = 1,
     parameter MIN_FRAME_LENGTH = 64,
-    parameter PTP_TS_ENABLE = 0,
-    parameter PTP_TS_FMT_TOD = 1,
-    parameter PTP_TS_WIDTH = PTP_TS_FMT_TOD ? 96 : 64,
-    parameter TX_PTP_TS_CTRL_IN_TUSER = 0,
-    parameter TX_PTP_TAG_ENABLE = PTP_TS_ENABLE,
+    parameter TX_PTP_TS_ENABLE = 0,
+    parameter TX_PTP_TS_WIDTH = 96,
+    parameter TX_PTP_TAG_ENABLE = TX_PTP_TS_ENABLE,
     parameter TX_PTP_TAG_WIDTH = 16,
-    parameter TX_USER_WIDTH = (PTP_TS_ENABLE ? (TX_PTP_TAG_ENABLE ? TX_PTP_TAG_WIDTH : 0) + (TX_PTP_TS_CTRL_IN_TUSER ? 1 : 0) : 0) + 1,
-    parameter RX_USER_WIDTH = (PTP_TS_ENABLE ? PTP_TS_WIDTH : 0) + 1,
-    parameter PFC_ENABLE = 0,
-    parameter PAUSE_ENABLE = PFC_ENABLE
+    parameter RX_PTP_TS_ENABLE = 0,
+    parameter RX_PTP_TS_WIDTH = 96,
+    parameter TX_USER_WIDTH = (TX_PTP_TAG_ENABLE ? TX_PTP_TAG_WIDTH : 0) + 1,
+    parameter RX_USER_WIDTH = (RX_PTP_TS_ENABLE ? RX_PTP_TS_WIDTH : 0) + 1
 )
 (
     input  wire                         rx_clk,
@@ -83,37 +77,12 @@ module eth_mac_1g #
     /*
      * PTP
      */
-    input  wire [PTP_TS_WIDTH-1:0]      tx_ptp_ts,
-    input  wire [PTP_TS_WIDTH-1:0]      rx_ptp_ts,
-    output wire [PTP_TS_WIDTH-1:0]      tx_axis_ptp_ts,
+    input  wire [TX_PTP_TS_WIDTH-1:0]   tx_ptp_ts,
+    input  wire [RX_PTP_TS_WIDTH-1:0]   rx_ptp_ts,
+    output wire [TX_PTP_TS_WIDTH-1:0]   tx_axis_ptp_ts,
     output wire [TX_PTP_TAG_WIDTH-1:0]  tx_axis_ptp_ts_tag,
     output wire                         tx_axis_ptp_ts_valid,
 
-    /*
-     * Link-level Flow Control (LFC) (IEEE 802.3 annex 31B PAUSE)
-     */
-    input  wire                         tx_lfc_req,
-    input  wire                         tx_lfc_resend,
-    input  wire                         rx_lfc_en,
-    output wire                         rx_lfc_req,
-    input  wire                         rx_lfc_ack,
-
-    /*
-     * Priority Flow Control (PFC) (IEEE 802.3 annex 31D PFC)
-     */
-    input  wire [7:0]                   tx_pfc_req,
-    input  wire                         tx_pfc_resend,
-    input  wire [7:0]                   rx_pfc_en,
-    output wire [7:0]                   rx_pfc_req,
-    input  wire [7:0]                   rx_pfc_ack,
-
-    /*
-     * Pause interface
-     */
-    input  wire                         tx_lfc_pause_en,
-    input  wire                         tx_pause_req,
-    output wire                         tx_pause_ack,
-
     /*
      * Control
      */
@@ -130,82 +99,17 @@ module eth_mac_1g #
     output wire                         rx_start_packet,
     output wire                         rx_error_bad_frame,
     output wire                         rx_error_bad_fcs,
-    output wire                         stat_tx_mcf,
-    output wire                         stat_rx_mcf,
-    output wire                         stat_tx_lfc_pkt,
-    output wire                         stat_tx_lfc_xon,
-    output wire                         stat_tx_lfc_xoff,
-    output wire                         stat_tx_lfc_paused,
-    output wire                         stat_tx_pfc_pkt,
-    output wire [7:0]                   stat_tx_pfc_xon,
-    output wire [7:0]                   stat_tx_pfc_xoff,
-    output wire [7:0]                   stat_tx_pfc_paused,
-    output wire                         stat_rx_lfc_pkt,
-    output wire                         stat_rx_lfc_xon,
-    output wire                         stat_rx_lfc_xoff,
-    output wire                         stat_rx_lfc_paused,
-    output wire                         stat_rx_pfc_pkt,
-    output wire [7:0]                   stat_rx_pfc_xon,
-    output wire [7:0]                   stat_rx_pfc_xoff,
-    output wire [7:0]                   stat_rx_pfc_paused,
 
     /*
      * Configuration
      */
-    input  wire [7:0]                   cfg_ifg,
-    input  wire                         cfg_tx_enable,
-    input  wire                         cfg_rx_enable,
-    input  wire [47:0]                  cfg_mcf_rx_eth_dst_mcast,
-    input  wire                         cfg_mcf_rx_check_eth_dst_mcast,
-    input  wire [47:0]                  cfg_mcf_rx_eth_dst_ucast,
-    input  wire                         cfg_mcf_rx_check_eth_dst_ucast,
-    input  wire [47:0]                  cfg_mcf_rx_eth_src,
-    input  wire                         cfg_mcf_rx_check_eth_src,
-    input  wire [15:0]                  cfg_mcf_rx_eth_type,
-    input  wire [15:0]                  cfg_mcf_rx_opcode_lfc,
-    input  wire                         cfg_mcf_rx_check_opcode_lfc,
-    input  wire [15:0]                  cfg_mcf_rx_opcode_pfc,
-    input  wire                         cfg_mcf_rx_check_opcode_pfc,
-    input  wire                         cfg_mcf_rx_forward,
-    input  wire                         cfg_mcf_rx_enable,
-    input  wire [47:0]                  cfg_tx_lfc_eth_dst,
-    input  wire [47:0]                  cfg_tx_lfc_eth_src,
-    input  wire [15:0]                  cfg_tx_lfc_eth_type,
-    input  wire [15:0]                  cfg_tx_lfc_opcode,
-    input  wire                         cfg_tx_lfc_en,
-    input  wire [15:0]                  cfg_tx_lfc_quanta,
-    input  wire [15:0]                  cfg_tx_lfc_refresh,
-    input  wire [47:0]                  cfg_tx_pfc_eth_dst,
-    input  wire [47:0]                  cfg_tx_pfc_eth_src,
-    input  wire [15:0]                  cfg_tx_pfc_eth_type,
-    input  wire [15:0]                  cfg_tx_pfc_opcode,
-    input  wire                         cfg_tx_pfc_en,
-    input  wire [8*16-1:0]              cfg_tx_pfc_quanta,
-    input  wire [8*16-1:0]              cfg_tx_pfc_refresh,
-    input  wire [15:0]                  cfg_rx_lfc_opcode,
-    input  wire                         cfg_rx_lfc_en,
-    input  wire [15:0]                  cfg_rx_pfc_opcode,
-    input  wire                         cfg_rx_pfc_en
+    input  wire [7:0]                   ifg_delay
 );
 
-parameter MAC_CTRL_ENABLE = PAUSE_ENABLE || PFC_ENABLE;
-parameter TX_USER_WIDTH_INT = MAC_CTRL_ENABLE ? (PTP_TS_ENABLE ? (TX_PTP_TAG_ENABLE ? TX_PTP_TAG_WIDTH : 0) + 1 : 0) + 1 : TX_USER_WIDTH;
-
-wire [DATA_WIDTH-1:0]         tx_axis_tdata_int;
-wire                          tx_axis_tvalid_int;
-wire                          tx_axis_tready_int;
-wire                          tx_axis_tlast_int;
-wire [TX_USER_WIDTH_INT-1:0]  tx_axis_tuser_int;
-
-wire [DATA_WIDTH-1:0]     rx_axis_tdata_int;
-wire                      rx_axis_tvalid_int;
-wire                      rx_axis_tlast_int;
-wire [RX_USER_WIDTH-1:0]  rx_axis_tuser_int;
-
 axis_gmii_rx #(
     .DATA_WIDTH(DATA_WIDTH),
-    .PTP_TS_ENABLE(PTP_TS_ENABLE),
-    .PTP_TS_WIDTH(PTP_TS_WIDTH),
+    .PTP_TS_ENABLE(RX_PTP_TS_ENABLE),
+    .PTP_TS_WIDTH(RX_PTP_TS_WIDTH),
     .USER_WIDTH(RX_USER_WIDTH)
 )
 axis_gmii_rx_inst (
@@ -214,14 +118,13 @@ axis_gmii_rx_inst (
     .gmii_rxd(gmii_rxd),
     .gmii_rx_dv(gmii_rx_dv),
     .gmii_rx_er(gmii_rx_er),
-    .m_axis_tdata(rx_axis_tdata_int),
-    .m_axis_tvalid(rx_axis_tvalid_int),
-    .m_axis_tlast(rx_axis_tlast_int),
-    .m_axis_tuser(rx_axis_tuser_int),
+    .m_axis_tdata(rx_axis_tdata),
+    .m_axis_tvalid(rx_axis_tvalid),
+    .m_axis_tlast(rx_axis_tlast),
+    .m_axis_tuser(rx_axis_tuser),
     .ptp_ts(rx_ptp_ts),
     .clk_enable(rx_clk_enable),
     .mii_select(rx_mii_select),
-    .cfg_rx_enable(cfg_rx_enable),
     .start_packet(rx_start_packet),
     .error_bad_frame(rx_error_bad_frame),
     .error_bad_fcs(rx_error_bad_fcs)
@@ -231,21 +134,20 @@ axis_gmii_tx #(
     .DATA_WIDTH(DATA_WIDTH),
     .ENABLE_PADDING(ENABLE_PADDING),
     .MIN_FRAME_LENGTH(MIN_FRAME_LENGTH),
-    .PTP_TS_ENABLE(PTP_TS_ENABLE),
-    .PTP_TS_WIDTH(PTP_TS_WIDTH),
-    .PTP_TS_CTRL_IN_TUSER(MAC_CTRL_ENABLE ? PTP_TS_ENABLE : TX_PTP_TS_CTRL_IN_TUSER),
+    .PTP_TS_ENABLE(TX_PTP_TS_ENABLE),
+    .PTP_TS_WIDTH(TX_PTP_TS_WIDTH),
     .PTP_TAG_ENABLE(TX_PTP_TAG_ENABLE),
     .PTP_TAG_WIDTH(TX_PTP_TAG_WIDTH),
-    .USER_WIDTH(TX_USER_WIDTH_INT)
+    .USER_WIDTH(TX_USER_WIDTH)
 )
 axis_gmii_tx_inst (
     .clk(tx_clk),
     .rst(tx_rst),
-    .s_axis_tdata(tx_axis_tdata_int),
-    .s_axis_tvalid(tx_axis_tvalid_int),
-    .s_axis_tready(tx_axis_tready_int),
-    .s_axis_tlast(tx_axis_tlast_int),
-    .s_axis_tuser(tx_axis_tuser_int),
+    .s_axis_tdata(tx_axis_tdata),
+    .s_axis_tvalid(tx_axis_tvalid),
+    .s_axis_tready(tx_axis_tready),
+    .s_axis_tlast(tx_axis_tlast),
+    .s_axis_tuser(tx_axis_tuser),
     .gmii_txd(gmii_txd),
     .gmii_tx_en(gmii_tx_en),
     .gmii_tx_er(gmii_tx_er),
@@ -255,390 +157,9 @@ axis_gmii_tx_inst (
     .m_axis_ptp_ts_valid(tx_axis_ptp_ts_valid),
     .clk_enable(tx_clk_enable),
     .mii_select(tx_mii_select),
-    .cfg_ifg(cfg_ifg),
-    .cfg_tx_enable(cfg_tx_enable),
+    .ifg_delay(ifg_delay),
     .start_packet(tx_start_packet),
     .error_underflow(tx_error_underflow)
 );
 
-generate
-
-if (MAC_CTRL_ENABLE) begin : mac_ctrl
-
-    localparam MCF_PARAMS_SIZE = PFC_ENABLE ? 18 : 2;
-
-    wire                          tx_mcf_valid;
-    wire                          tx_mcf_ready;
-    wire [47:0]                   tx_mcf_eth_dst;
-    wire [47:0]                   tx_mcf_eth_src;
-    wire [15:0]                   tx_mcf_eth_type;
-    wire [15:0]                   tx_mcf_opcode;
-    wire [MCF_PARAMS_SIZE*8-1:0]  tx_mcf_params;
-
-    wire                          rx_mcf_valid;
-    wire [47:0]                   rx_mcf_eth_dst;
-    wire [47:0]                   rx_mcf_eth_src;
-    wire [15:0]                   rx_mcf_eth_type;
-    wire [15:0]                   rx_mcf_opcode;
-    wire [MCF_PARAMS_SIZE*8-1:0]  rx_mcf_params;
-
-    // terminate LFC pause requests from RX internally on TX side
-    wire                          tx_pause_req_int;
-    wire                          rx_lfc_ack_int;
-
-    reg tx_lfc_req_sync_reg_1 = 1'b0;
-    reg tx_lfc_req_sync_reg_2 = 1'b0;
-    reg tx_lfc_req_sync_reg_3 = 1'b0;
-
-    always @(posedge rx_clk or posedge rx_rst) begin
-        if (rx_rst) begin
-            tx_lfc_req_sync_reg_1 <= 1'b0;
-        end else begin
-            tx_lfc_req_sync_reg_1 <= rx_lfc_req;
-        end
-    end
-
-    always @(posedge tx_clk or posedge tx_rst) begin
-        if (tx_rst) begin
-            tx_lfc_req_sync_reg_2 <= 1'b0;
-            tx_lfc_req_sync_reg_3 <= 1'b0;
-        end else begin
-            tx_lfc_req_sync_reg_2 <= tx_lfc_req_sync_reg_1;
-            tx_lfc_req_sync_reg_3 <= tx_lfc_req_sync_reg_2;
-        end
-    end
-
-    reg rx_lfc_ack_sync_reg_1 = 1'b0;
-    reg rx_lfc_ack_sync_reg_2 = 1'b0;
-    reg rx_lfc_ack_sync_reg_3 = 1'b0;
-
-    always @(posedge tx_clk or posedge tx_rst) begin
-        if (tx_rst) begin
-            rx_lfc_ack_sync_reg_1 <= 1'b0;
-        end else begin
-            rx_lfc_ack_sync_reg_1 <= tx_lfc_pause_en ? tx_pause_ack : 0;
-        end
-    end
-
-    always @(posedge rx_clk or posedge rx_rst) begin
-        if (rx_rst) begin
-            rx_lfc_ack_sync_reg_2 <= 1'b0;
-            rx_lfc_ack_sync_reg_3 <= 1'b0;
-        end else begin
-            rx_lfc_ack_sync_reg_2 <= rx_lfc_ack_sync_reg_1;
-            rx_lfc_ack_sync_reg_3 <= rx_lfc_ack_sync_reg_2;
-        end
-    end
-
-    assign tx_pause_req_int = tx_pause_req || (tx_lfc_pause_en ? tx_lfc_req_sync_reg_3 : 0);
-
-    assign rx_lfc_ack_int = rx_lfc_ack || rx_lfc_ack_sync_reg_3;
-
-    // handle PTP TS enable bit in tuser
-    wire [TX_USER_WIDTH_INT-1:0] tx_axis_tuser_in;
-
-    if (PTP_TS_ENABLE && !TX_PTP_TS_CTRL_IN_TUSER) begin
-        assign tx_axis_tuser_in = {tx_axis_tuser[TX_USER_WIDTH-1:1], 1'b1, tx_axis_tuser[0]};
-    end else begin
-        assign tx_axis_tuser_in = tx_axis_tuser;
-    end
-
-    mac_ctrl_tx #(
-        .DATA_WIDTH(DATA_WIDTH),
-        .KEEP_ENABLE(0),
-        .ID_ENABLE(0),
-        .DEST_ENABLE(0),
-        .USER_ENABLE(1),
-        .USER_WIDTH(TX_USER_WIDTH_INT),
-        .MCF_PARAMS_SIZE(MCF_PARAMS_SIZE)
-    )
-    mac_ctrl_tx_inst (
-        .clk(tx_clk),
-        .rst(tx_rst),
-
-        /*
-         * AXI stream input
-         */
-        .s_axis_tdata(tx_axis_tdata),
-        .s_axis_tkeep(1'b1),
-        .s_axis_tvalid(tx_axis_tvalid),
-        .s_axis_tready(tx_axis_tready),
-        .s_axis_tlast(tx_axis_tlast),
-        .s_axis_tid(0),
-        .s_axis_tdest(0),
-        .s_axis_tuser(tx_axis_tuser_in),
-
-        /*
-         * AXI stream output
-         */
-        .m_axis_tdata(tx_axis_tdata_int),
-        .m_axis_tkeep(),
-        .m_axis_tvalid(tx_axis_tvalid_int),
-        .m_axis_tready(tx_axis_tready_int),
-        .m_axis_tlast(tx_axis_tlast_int),
-        .m_axis_tid(),
-        .m_axis_tdest(),
-        .m_axis_tuser(tx_axis_tuser_int),
-
-        /*
-         * MAC control frame interface
-         */
-        .mcf_valid(tx_mcf_valid),
-        .mcf_ready(tx_mcf_ready),
-        .mcf_eth_dst(tx_mcf_eth_dst),
-        .mcf_eth_src(tx_mcf_eth_src),
-        .mcf_eth_type(tx_mcf_eth_type),
-        .mcf_opcode(tx_mcf_opcode),
-        .mcf_params(tx_mcf_params),
-        .mcf_id(0),
-        .mcf_dest(0),
-        .mcf_user(0),
-
-        /*
-         * Pause interface
-         */
-        .tx_pause_req(tx_pause_req_int),
-        .tx_pause_ack(tx_pause_ack),
-
-        /*
-         * Status
-         */
-        .stat_tx_mcf(stat_tx_mcf)
-    );
-
-    mac_ctrl_rx #(
-        .DATA_WIDTH(DATA_WIDTH),
-        .KEEP_ENABLE(0),
-        .ID_ENABLE(0),
-        .DEST_ENABLE(0),
-        .USER_ENABLE(1),
-        .USER_WIDTH(RX_USER_WIDTH),
-        .USE_READY(0),
-        .MCF_PARAMS_SIZE(MCF_PARAMS_SIZE)
-    )
-    mac_ctrl_rx_inst (
-        .clk(rx_clk),
-        .rst(rx_rst),
-
-        /*
-         * AXI stream input
-         */
-        .s_axis_tdata(rx_axis_tdata_int),
-        .s_axis_tkeep(1'b1),
-        .s_axis_tvalid(rx_axis_tvalid_int),
-        .s_axis_tready(),
-        .s_axis_tlast(rx_axis_tlast_int),
-        .s_axis_tid(0),
-        .s_axis_tdest(0),
-        .s_axis_tuser(rx_axis_tuser_int),
-
-        /*
-         * AXI stream output
-         */
-        .m_axis_tdata(rx_axis_tdata),
-        .m_axis_tkeep(),
-        .m_axis_tvalid(rx_axis_tvalid),
-        .m_axis_tready(1'b1),
-        .m_axis_tlast(rx_axis_tlast),
-        .m_axis_tid(),
-        .m_axis_tdest(),
-        .m_axis_tuser(rx_axis_tuser),
-
-        /*
-         * MAC control frame interface
-         */
-        .mcf_valid(rx_mcf_valid),
-        .mcf_eth_dst(rx_mcf_eth_dst),
-        .mcf_eth_src(rx_mcf_eth_src),
-        .mcf_eth_type(rx_mcf_eth_type),
-        .mcf_opcode(rx_mcf_opcode),
-        .mcf_params(rx_mcf_params),
-        .mcf_id(),
-        .mcf_dest(),
-        .mcf_user(),
-
-        /*
-         * Configuration
-         */
-        .cfg_mcf_rx_eth_dst_mcast(cfg_mcf_rx_eth_dst_mcast),
-        .cfg_mcf_rx_check_eth_dst_mcast(cfg_mcf_rx_check_eth_dst_mcast),
-        .cfg_mcf_rx_eth_dst_ucast(cfg_mcf_rx_eth_dst_ucast),
-        .cfg_mcf_rx_check_eth_dst_ucast(cfg_mcf_rx_check_eth_dst_ucast),
-        .cfg_mcf_rx_eth_src(cfg_mcf_rx_eth_src),
-        .cfg_mcf_rx_check_eth_src(cfg_mcf_rx_check_eth_src),
-        .cfg_mcf_rx_eth_type(cfg_mcf_rx_eth_type),
-        .cfg_mcf_rx_opcode_lfc(cfg_mcf_rx_opcode_lfc),
-        .cfg_mcf_rx_check_opcode_lfc(cfg_mcf_rx_check_opcode_lfc),
-        .cfg_mcf_rx_opcode_pfc(cfg_mcf_rx_opcode_pfc),
-        .cfg_mcf_rx_check_opcode_pfc(cfg_mcf_rx_check_opcode_pfc),
-        .cfg_mcf_rx_forward(cfg_mcf_rx_forward),
-        .cfg_mcf_rx_enable(cfg_mcf_rx_enable),
-
-        /*
-         * Status
-         */
-        .stat_rx_mcf(stat_rx_mcf)
-    );
-
-    mac_pause_ctrl_tx #(
-        .MCF_PARAMS_SIZE(MCF_PARAMS_SIZE),
-        .PFC_ENABLE(PFC_ENABLE)
-    )
-    mac_pause_ctrl_tx_inst (
-        .clk(tx_clk),
-        .rst(tx_rst),
-
-        /*
-         * MAC control frame interface
-         */
-        .mcf_valid(tx_mcf_valid),
-        .mcf_ready(tx_mcf_ready),
-        .mcf_eth_dst(tx_mcf_eth_dst),
-        .mcf_eth_src(tx_mcf_eth_src),
-        .mcf_eth_type(tx_mcf_eth_type),
-        .mcf_opcode(tx_mcf_opcode),
-        .mcf_params(tx_mcf_params),
-
-        /*
-         * Pause (IEEE 802.3 annex 31B)
-         */
-        .tx_lfc_req(tx_lfc_req),
-        .tx_lfc_resend(tx_lfc_resend),
-
-        /*
-         * Priority Flow Control (PFC) (IEEE 802.3 annex 31D)
-         */
-        .tx_pfc_req(tx_pfc_req),
-        .tx_pfc_resend(tx_pfc_resend),
-
-        /*
-         * Configuration
-         */
-        .cfg_tx_lfc_eth_dst(cfg_tx_lfc_eth_dst),
-        .cfg_tx_lfc_eth_src(cfg_tx_lfc_eth_src),
-        .cfg_tx_lfc_eth_type(cfg_tx_lfc_eth_type),
-        .cfg_tx_lfc_opcode(cfg_tx_lfc_opcode),
-        .cfg_tx_lfc_en(cfg_tx_lfc_en),
-        .cfg_tx_lfc_quanta(cfg_tx_lfc_quanta),
-        .cfg_tx_lfc_refresh(cfg_tx_lfc_refresh),
-        .cfg_tx_pfc_eth_dst(cfg_tx_pfc_eth_dst),
-        .cfg_tx_pfc_eth_src(cfg_tx_pfc_eth_src),
-        .cfg_tx_pfc_eth_type(cfg_tx_pfc_eth_type),
-        .cfg_tx_pfc_opcode(cfg_tx_pfc_opcode),
-        .cfg_tx_pfc_en(cfg_tx_pfc_en),
-        .cfg_tx_pfc_quanta(cfg_tx_pfc_quanta),
-        .cfg_tx_pfc_refresh(cfg_tx_pfc_refresh),
-        .cfg_quanta_step(tx_mii_select ? (4*256)/512 : (8*256)/512),
-        .cfg_quanta_clk_en(tx_clk_enable),
-
-        /*
-         * Status
-         */
-        .stat_tx_lfc_pkt(stat_tx_lfc_pkt),
-        .stat_tx_lfc_xon(stat_tx_lfc_xon),
-        .stat_tx_lfc_xoff(stat_tx_lfc_xoff),
-        .stat_tx_lfc_paused(stat_tx_lfc_paused),
-        .stat_tx_pfc_pkt(stat_tx_pfc_pkt),
-        .stat_tx_pfc_xon(stat_tx_pfc_xon),
-        .stat_tx_pfc_xoff(stat_tx_pfc_xoff),
-        .stat_tx_pfc_paused(stat_tx_pfc_paused)
-    );
-
-    mac_pause_ctrl_rx #(
-        .MCF_PARAMS_SIZE(18),
-        .PFC_ENABLE(PFC_ENABLE)
-    )
-    mac_pause_ctrl_rx_inst (
-        .clk(rx_clk),
-        .rst(rx_rst),
-
-        /*
-         * MAC control frame interface
-         */
-        .mcf_valid(rx_mcf_valid),
-        .mcf_eth_dst(rx_mcf_eth_dst),
-        .mcf_eth_src(rx_mcf_eth_src),
-        .mcf_eth_type(rx_mcf_eth_type),
-        .mcf_opcode(rx_mcf_opcode),
-        .mcf_params(rx_mcf_params),
-
-        /*
-         * Pause (IEEE 802.3 annex 31B)
-         */
-        .rx_lfc_en(rx_lfc_en),
-        .rx_lfc_req(rx_lfc_req),
-        .rx_lfc_ack(rx_lfc_ack_int),
-
-        /*
-         * Priority Flow Control (PFC) (IEEE 802.3 annex 31D)
-         */
-        .rx_pfc_en(rx_pfc_en),
-        .rx_pfc_req(rx_pfc_req),
-        .rx_pfc_ack(rx_pfc_ack),
-
-        /*
-         * Configuration
-         */
-        .cfg_rx_lfc_opcode(cfg_rx_lfc_opcode),
-        .cfg_rx_lfc_en(cfg_rx_lfc_en),
-        .cfg_rx_pfc_opcode(cfg_rx_pfc_opcode),
-        .cfg_rx_pfc_en(cfg_rx_pfc_en),
-        .cfg_quanta_step(rx_mii_select ? (4*256)/512 : (8*256)/512),
-        .cfg_quanta_clk_en(rx_clk_enable),
-
-        /*
-         * Status
-         */
-        .stat_rx_lfc_pkt(stat_rx_lfc_pkt),
-        .stat_rx_lfc_xon(stat_rx_lfc_xon),
-        .stat_rx_lfc_xoff(stat_rx_lfc_xoff),
-        .stat_rx_lfc_paused(stat_rx_lfc_paused),
-        .stat_rx_pfc_pkt(stat_rx_pfc_pkt),
-        .stat_rx_pfc_xon(stat_rx_pfc_xon),
-        .stat_rx_pfc_xoff(stat_rx_pfc_xoff),
-        .stat_rx_pfc_paused(stat_rx_pfc_paused)
-    );
-
-end else begin
-
-    assign tx_axis_tdata_int = tx_axis_tdata;
-    assign tx_axis_tvalid_int = tx_axis_tvalid;
-    assign tx_axis_tready = tx_axis_tready_int;
-    assign tx_axis_tlast_int = tx_axis_tlast;
-    assign tx_axis_tuser_int = tx_axis_tuser;
-
-    assign rx_axis_tdata = rx_axis_tdata_int;
-    assign rx_axis_tvalid = rx_axis_tvalid_int;
-    assign rx_axis_tlast = rx_axis_tlast_int;
-    assign rx_axis_tuser = rx_axis_tuser_int;
-
-    assign rx_lfc_req = 0;
-    assign rx_pfc_req = 0;
-    assign tx_pause_ack = 0;
-
-    assign stat_tx_mcf = 0;
-    assign stat_rx_mcf = 0;
-    assign stat_tx_lfc_pkt = 0;
-    assign stat_tx_lfc_xon = 0;
-    assign stat_tx_lfc_xoff = 0;
-    assign stat_tx_lfc_paused = 0;
-    assign stat_tx_pfc_pkt = 0;
-    assign stat_tx_pfc_xon = 0;
-    assign stat_tx_pfc_xoff = 0;
-    assign stat_tx_pfc_paused = 0;
-    assign stat_rx_lfc_pkt = 0;
-    assign stat_rx_lfc_xon = 0;
-    assign stat_rx_lfc_xoff = 0;
-    assign stat_rx_lfc_paused = 0;
-    assign stat_rx_pfc_pkt = 0;
-    assign stat_rx_pfc_xon = 0;
-    assign stat_rx_pfc_xoff = 0;
-    assign stat_rx_pfc_paused = 0;
-
-end
-
-endgenerate
-
 endmodule
-
-`resetall
diff --git a/rtl/eth_mac_1g_rgmii.v b/rtl/eth_mac_1g_rgmii.v
index 3f966d9..0ee67a6 100644
--- a/rtl/eth_mac_1g_rgmii.v
+++ b/rtl/eth_mac_1g_rgmii.v
@@ -24,38 +24,23 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * 1G Ethernet MAC with RGMII interface
  */
 module eth_mac_1g_rgmii #
 (
-    // target ("SIM", "GENERIC", "XILINX", "ALTERA")
-    parameter TARGET = "GENERIC",
-    // IODDR style ("IODDR", "IODDR2")
-    // Use IODDR for Virtex-4, Virtex-5, Virtex-6, 7 Series, Ultrascale
-    // Use IODDR2 for Spartan-6
-    parameter IODDR_STYLE = "IODDR2",
-    // Clock input style ("BUFG", "BUFR", "BUFIO", "BUFIO2")
-    // Use BUFR for Virtex-6, 7-series
-    // Use BUFG for Virtex-5, Spartan-6, Ultrascale
-    parameter CLOCK_INPUT_STYLE = "BUFG",
-    // Use 90 degree clock for RGMII transmit ("TRUE", "FALSE")
-    parameter USE_CLK90 = "TRUE",
     parameter ENABLE_PADDING = 1,
     parameter MIN_FRAME_LENGTH = 64
 )
 (
-    input  wire        gtx_clk,
-    input  wire        gtx_clk90,
-    input  wire        gtx_rst,
+    input  wire        clk250,
+    input  wire        clk250_rst,
+    input  wire        tx_clk_gen_rst,
+
     output wire        rx_clk,
-    output wire        rx_rst,
+    input  wire        rx_rst,
     output wire        tx_clk,
-    output wire        tx_rst,
+    input  wire        tx_rst,
 
     /*
      * AXI input
@@ -95,9 +80,7 @@ module eth_mac_1g_rgmii #
     /*
      * Configuration
      */
-    input  wire [7:0]  cfg_ifg,
-    input  wire        cfg_tx_enable,
-    input  wire        cfg_rx_enable
+    input  wire [7:0]  ifg_delay
 );
 
 wire [7:0]  mac_gmii_rxd;
@@ -108,50 +91,105 @@ wire [7:0]  mac_gmii_txd;
 wire        mac_gmii_tx_en;
 wire        mac_gmii_tx_er;
 
-reg [1:0] speed_reg = 2'b10;
-reg mii_select_reg = 1'b0;
+reg [1:0] speed_reg;
+reg mii_select_reg;
 
-(* srl_style = "register" *)
-reg [1:0] tx_mii_select_sync = 2'd0;
+wire tx_mii_select_sync;
+wire rx_mii_select_sync;
+/*
+reg [1:0] tx_mii_select_sync;
 
 always @(posedge tx_clk) begin
     tx_mii_select_sync <= {tx_mii_select_sync[0], mii_select_reg};
 end
 
-(* srl_style = "register" *)
-reg [1:0] rx_mii_select_sync = 2'd0;
+reg [1:0] rx_mii_select_sync;
 
 always @(posedge rx_clk) begin
     rx_mii_select_sync <= {rx_mii_select_sync[0], mii_select_reg};
 end
+*/
+/*
+// UNUSED as gtx_clk == tx_clk
+bsg_launch_sync_sync #(
+   .width_p(1)
+  ,.use_negedge_for_launch_p(0)
+  ,.use_async_reset_p(0)
+) tx_mii_select_reg_sync (
+   .iclk_i(gtx_clk)
+  ,.iclk_reset_i(gtx_rst)
+  ,.oclk_i(tx_clk)
+  ,.iclk_data_i(mii_select_reg)
+  ,.iclk_data_o() // UNUSED
+  ,.oclk_data_o(tx_mii_select_sync)
+);*/
+assign tx_mii_select_sync = mii_select_reg;
+
+bsg_launch_sync_sync #(
+   .width_p(1)
+  ,.use_negedge_for_launch_p(0)
+  ,.use_async_reset_p(0)
+) rx_mii_select_reg_sync (
+   .iclk_i(tx_clk)
+  ,.iclk_reset_i(tx_rst)
+  ,.oclk_i(rx_clk)
+  ,.iclk_data_i(mii_select_reg)
+  ,.iclk_data_o() // UNUSED
+  ,.oclk_data_o(rx_mii_select_sync)
+);
 
 // PHY speed detection
-reg [2:0] rx_prescale = 3'd0;
+
+
+reg [2:0] rx_prescale;
 
 always @(posedge rx_clk) begin
-    rx_prescale <= rx_prescale + 3'd1;
+    if(rx_rst)
+        rx_prescale <= 3'd0;
+    else
+        rx_prescale <= rx_prescale + 3'd1;
 end
 
-(* srl_style = "register" *)
-reg [2:0] rx_prescale_sync = 3'd0;
+reg rx_prescale_sync_2;
+reg rx_prescale_sync_3;
+/*
+reg [2:0] rx_prescale_sync;
 
 always @(posedge gtx_clk) begin
     rx_prescale_sync <= {rx_prescale_sync[1:0], rx_prescale[2]};
 end
+*/
+
+always @(posedge tx_clk) begin
+    rx_prescale_sync_3 <= rx_prescale_sync_2;
+end
+bsg_launch_sync_sync #(
+   .width_p(1)
+  ,.use_negedge_for_launch_p(0)
+  ,.use_async_reset_p(0)
+) rx_prescale_sync (
+   .iclk_i(rx_clk)
+  ,.iclk_reset_i(rx_rst)
+  ,.oclk_i(tx_clk)
+  ,.iclk_data_i(rx_prescale[2])
+  ,.iclk_data_o() // UNUSED
+  ,.oclk_data_o(rx_prescale_sync_2)
+);
 
-reg [6:0] rx_speed_count_1 = 0;
-reg [1:0] rx_speed_count_2 = 0;
 
-always @(posedge gtx_clk) begin
-    if (gtx_rst) begin
+reg [6:0] rx_speed_count_1;
+reg [1:0] rx_speed_count_2;
+
+always @(posedge tx_clk) begin
+    if (tx_rst) begin
         rx_speed_count_1 <= 0;
         rx_speed_count_2 <= 0;
         speed_reg <= 2'b10;
         mii_select_reg <= 1'b0;
     end else begin
         rx_speed_count_1 <= rx_speed_count_1 + 1;
-        
-        if (rx_prescale_sync[1] ^ rx_prescale_sync[2]) begin
+
+        if (rx_prescale_sync_2 ^ rx_prescale_sync_3) begin
             rx_speed_count_2 <= rx_speed_count_2 + 1;
         end
 
@@ -182,16 +220,10 @@ end
 
 assign speed = speed_reg;
 
-rgmii_phy_if #(
-    .TARGET(TARGET),
-    .IODDR_STYLE(IODDR_STYLE),
-    .CLOCK_INPUT_STYLE(CLOCK_INPUT_STYLE),
-    .USE_CLK90(USE_CLK90)
-)
-rgmii_phy_if_inst (
-    .clk(gtx_clk),
-    .clk90(gtx_clk90),
-    .rst(gtx_rst),
+rgmii_phy_if rgmii_phy_if_inst (
+    .clk250(clk250),
+    .clk250_rst(clk250_rst),
+    .tx_clk_gen_rst(tx_clk_gen_rst),
 
     .mac_gmii_rx_clk(rx_clk),
     .mac_gmii_rx_rst(rx_rst),
@@ -241,16 +273,12 @@ eth_mac_1g_inst (
     .gmii_tx_er(mac_gmii_tx_er),
     .rx_clk_enable(1'b1),
     .tx_clk_enable(mac_gmii_tx_clk_en),
-    .rx_mii_select(rx_mii_select_sync[1]),
-    .tx_mii_select(tx_mii_select_sync[1]),
+    .rx_mii_select(rx_mii_select_sync),
+    .tx_mii_select(tx_mii_select_sync),
     .tx_error_underflow(tx_error_underflow),
     .rx_error_bad_frame(rx_error_bad_frame),
     .rx_error_bad_fcs(rx_error_bad_fcs),
-    .cfg_ifg(cfg_ifg),
-    .cfg_tx_enable(cfg_tx_enable),
-    .cfg_rx_enable(cfg_rx_enable)
+    .ifg_delay(ifg_delay)
 );
 
 endmodule
-
-`resetall
diff --git a/rtl/eth_mac_1g_rgmii_fifo.v b/rtl/eth_mac_1g_rgmii_fifo.v
index c63af55..34d6b6f 100644
--- a/rtl/eth_mac_1g_rgmii_fifo.v
+++ b/rtl/eth_mac_1g_rgmii_fifo.v
@@ -24,52 +24,43 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * 1G Ethernet MAC with RGMII interface and TX and RX FIFOs
  */
 module eth_mac_1g_rgmii_fifo #
 (
-    // target ("SIM", "GENERIC", "XILINX", "ALTERA")
-    parameter TARGET = "GENERIC",
-    // IODDR style ("IODDR", "IODDR2")
-    // Use IODDR for Virtex-4, Virtex-5, Virtex-6, 7 Series, Ultrascale
-    // Use IODDR2 for Spartan-6
-    parameter IODDR_STYLE = "IODDR2",
-    // Clock input style ("BUFG", "BUFR", "BUFIO", "BUFIO2")
-    // Use BUFR for Virtex-6, 7-series
-    // Use BUFG for Virtex-5, Spartan-6, Ultrascale
-    parameter CLOCK_INPUT_STYLE = "BUFG",
-    // Use 90 degree clock for RGMII transmit ("TRUE", "FALSE")
-    parameter USE_CLK90 = "TRUE",
     parameter AXIS_DATA_WIDTH = 8,
     parameter AXIS_KEEP_ENABLE = (AXIS_DATA_WIDTH>8),
     parameter AXIS_KEEP_WIDTH = (AXIS_DATA_WIDTH/8),
     parameter ENABLE_PADDING = 1,
     parameter MIN_FRAME_LENGTH = 64,
     parameter TX_FIFO_DEPTH = 4096,
-    parameter TX_FIFO_RAM_PIPELINE = 1,
+    parameter TX_FIFO_PIPELINE_OUTPUT = 2,
     parameter TX_FRAME_FIFO = 1,
     parameter TX_DROP_OVERSIZE_FRAME = TX_FRAME_FIFO,
     parameter TX_DROP_BAD_FRAME = TX_DROP_OVERSIZE_FRAME,
     parameter TX_DROP_WHEN_FULL = 0,
     parameter RX_FIFO_DEPTH = 4096,
-    parameter RX_FIFO_RAM_PIPELINE = 1,
+    parameter RX_FIFO_PIPELINE_OUTPUT = 2,
     parameter RX_FRAME_FIFO = 1,
     parameter RX_DROP_OVERSIZE_FRAME = RX_FRAME_FIFO,
     parameter RX_DROP_BAD_FRAME = RX_DROP_OVERSIZE_FRAME,
     parameter RX_DROP_WHEN_FULL = RX_DROP_OVERSIZE_FRAME
 )
 (
-    input  wire                       gtx_clk,
-    input  wire                       gtx_clk90,
-    input  wire                       gtx_rst,
     input  wire                       logic_clk,
     input  wire                       logic_rst,
 
+    input  wire                       clk250,
+    input  wire                       clk250_rst,
+    input  wire                       tx_clk_gen_rst,
+
+    output wire                       tx_clk,
+    input  wire                       tx_rst,
+
+    output wire                       rx_clk,
+    input  wire                       rx_rst,
+
     /*
      * AXI input
      */
@@ -117,16 +108,9 @@ module eth_mac_1g_rgmii_fifo #
     /*
      * Configuration
      */
-    input  wire [7:0]                 cfg_ifg,
-    input  wire                       cfg_tx_enable,
-    input  wire                       cfg_rx_enable
+    input  wire [7:0]                 ifg_delay
 );
 
-wire tx_clk;
-wire rx_clk;
-wire tx_rst;
-wire rx_rst;
-
 wire [7:0]  tx_fifo_axis_tdata;
 wire        tx_fifo_axis_tvalid;
 wire        tx_fifo_axis_tready;
@@ -141,13 +125,14 @@ wire        rx_fifo_axis_tuser;
 // synchronize MAC status signals into logic clock domain
 wire tx_error_underflow_int;
 
-reg [0:0] tx_sync_reg_1 = 1'b0;
-reg [0:0] tx_sync_reg_2 = 1'b0;
-reg [0:0] tx_sync_reg_3 = 1'b0;
-reg [0:0] tx_sync_reg_4 = 1'b0;
+wire [0:0] tx_sync_reg_1_n;
+reg [0:0] tx_sync_reg_1;
+reg [0:0] tx_sync_reg_2;
+reg [0:0] tx_sync_reg_3;
+reg [0:0] tx_sync_reg_4;
 
 assign tx_error_underflow = tx_sync_reg_3[0] ^ tx_sync_reg_4[0];
-
+/*
 always @(posedge tx_clk or posedge tx_rst) begin
     if (tx_rst) begin
         tx_sync_reg_1 <= 1'b0;
@@ -167,18 +152,42 @@ always @(posedge logic_clk or posedge logic_rst) begin
         tx_sync_reg_4 <= tx_sync_reg_3;
     end
 end
+*/
+always @(posedge logic_clk) begin
+    if(logic_rst)
+        tx_sync_reg_4 <= '0;
+    else
+        tx_sync_reg_4 <= tx_sync_reg_3;
+end
+
+assign tx_sync_reg_1_n[0] = tx_sync_reg_1[0] ^ {tx_error_underflow_int};
+bsg_launch_sync_sync #(
+   .width_p(1)
+  ,.use_negedge_for_launch_p(0)
+  ,.use_async_reset_p(0)
+) tx_error_sync (
+   .iclk_i(tx_clk)
+  ,.iclk_reset_i(tx_rst)
+  ,.oclk_i(logic_clk)
+  ,.iclk_data_i(tx_sync_reg_1_n[0])
+  ,.iclk_data_o(tx_sync_reg_1[0])
+  ,.oclk_data_o(tx_sync_reg_3[0])
+);
 
 wire rx_error_bad_frame_int;
 wire rx_error_bad_fcs_int;
 
-reg [1:0] rx_sync_reg_1 = 2'd0;
-reg [1:0] rx_sync_reg_2 = 2'd0;
-reg [1:0] rx_sync_reg_3 = 2'd0;
-reg [1:0] rx_sync_reg_4 = 2'd0;
+wire [1:0] rx_sync_reg_1_n;
+reg [1:0] rx_sync_reg_1;
+reg [1:0] rx_sync_reg_2;
+reg [1:0] rx_sync_reg_3;
+reg [1:0] rx_sync_reg_4;
 
 assign rx_error_bad_frame = rx_sync_reg_3[0] ^ rx_sync_reg_4[0];
 assign rx_error_bad_fcs = rx_sync_reg_3[1] ^ rx_sync_reg_4[1];
 
+assign rx_sync_reg_1_n = rx_sync_reg_1 ^ {rx_error_bad_fcs_int, rx_error_bad_frame_int};
+/*
 always @(posedge rx_clk or posedge rx_rst) begin
     if (rx_rst) begin
         rx_sync_reg_1 <= 2'd0;
@@ -198,31 +207,64 @@ always @(posedge logic_clk or posedge logic_rst) begin
         rx_sync_reg_4 <= rx_sync_reg_3;
     end
 end
+*/
+
+always @(posedge logic_clk) begin
+    if(logic_rst)
+        rx_sync_reg_4 <= '0;
+    else
+        rx_sync_reg_4 <= rx_sync_reg_3;
+end
+
+bsg_launch_sync_sync #(
+   .width_p(2)
+  ,.use_negedge_for_launch_p(0)
+  ,.use_async_reset_p(0)
+) rx_error_sync (
+   .iclk_i(rx_clk)
+  ,.iclk_reset_i(rx_rst)
+  ,.oclk_i(logic_clk)
+  ,.iclk_data_i(rx_sync_reg_1_n)
+  ,.iclk_data_o(rx_sync_reg_1)
+  ,.oclk_data_o(rx_sync_reg_3)
+);
 
 wire [1:0] speed_int;
 
-reg [1:0] speed_sync_reg_1 = 2'b10;
-reg [1:0] speed_sync_reg_2 = 2'b10;
+reg [1:0] speed_sync_reg_1;
+reg [1:0] speed_sync_reg_2;
 
 assign speed = speed_sync_reg_2;
 
+/*
 always @(posedge logic_clk) begin
     speed_sync_reg_1 <= speed_int;
     speed_sync_reg_2 <= speed_sync_reg_1;
 end
+*/
+
+bsg_launch_sync_sync #(
+   .width_p(2)
+  ,.use_negedge_for_launch_p(0)
+  ,.use_async_reset_p(0)
+) speed_sync (
+   .iclk_i(tx_clk)
+  ,.iclk_reset_i(tx_rst)
+  ,.oclk_i(logic_clk)
+  ,.iclk_data_i(speed_int)
+  ,.iclk_data_o() // UNUSED
+  ,.oclk_data_o(speed_sync_reg_2)
+);
+
 
 eth_mac_1g_rgmii #(
-    .TARGET(TARGET),
-    .IODDR_STYLE(IODDR_STYLE),
-    .CLOCK_INPUT_STYLE(CLOCK_INPUT_STYLE),
-    .USE_CLK90(USE_CLK90),
     .ENABLE_PADDING(ENABLE_PADDING),
     .MIN_FRAME_LENGTH(MIN_FRAME_LENGTH)
 )
 eth_mac_1g_rgmii_inst (
-    .gtx_clk(gtx_clk),
-    .gtx_clk90(gtx_clk90),
-    .gtx_rst(gtx_rst),
+    .clk250(clk250),
+    .clk250_rst(clk250_rst),
+    .tx_clk_gen_rst(tx_clk_gen_rst),
     .tx_clk(tx_clk),
     .tx_rst(tx_rst),
     .rx_clk(rx_clk),
@@ -246,9 +288,7 @@ eth_mac_1g_rgmii_inst (
     .rx_error_bad_frame(rx_error_bad_frame_int),
     .rx_error_bad_fcs(rx_error_bad_fcs_int),
     .speed(speed_int),
-    .cfg_ifg(cfg_ifg),
-    .cfg_tx_enable(cfg_tx_enable),
-    .cfg_rx_enable(cfg_rx_enable)
+    .ifg_delay(ifg_delay)
 );
 
 axis_async_fifo_adapter #(
@@ -262,13 +302,14 @@ axis_async_fifo_adapter #(
     .DEST_ENABLE(0),
     .USER_ENABLE(1),
     .USER_WIDTH(1),
-    .RAM_PIPELINE(TX_FIFO_RAM_PIPELINE),
+    .PIPELINE_OUTPUT(TX_FIFO_PIPELINE_OUTPUT),
     .FRAME_FIFO(TX_FRAME_FIFO),
     .USER_BAD_FRAME_VALUE(1'b1),
     .USER_BAD_FRAME_MASK(1'b1),
     .DROP_OVERSIZE_FRAME(TX_DROP_OVERSIZE_FRAME),
     .DROP_BAD_FRAME(TX_DROP_BAD_FRAME),
-    .DROP_WHEN_FULL(TX_DROP_WHEN_FULL)
+    .DROP_WHEN_FULL(TX_DROP_WHEN_FULL),
+    .upstream_async_fifo_p(1)
 )
 tx_fifo (
     // AXI input
@@ -279,8 +320,8 @@ tx_fifo (
     .s_axis_tvalid(tx_axis_tvalid),
     .s_axis_tready(tx_axis_tready),
     .s_axis_tlast(tx_axis_tlast),
-    .s_axis_tid(0),
-    .s_axis_tdest(0),
+    .s_axis_tid(8'b0),
+    .s_axis_tdest(8'b0),
     .s_axis_tuser(tx_axis_tuser),
     // AXI output
     .m_clk(tx_clk),
@@ -313,25 +354,26 @@ axis_async_fifo_adapter #(
     .DEST_ENABLE(0),
     .USER_ENABLE(1),
     .USER_WIDTH(1),
-    .RAM_PIPELINE(RX_FIFO_RAM_PIPELINE),
+    .PIPELINE_OUTPUT(RX_FIFO_PIPELINE_OUTPUT),
     .FRAME_FIFO(RX_FRAME_FIFO),
     .USER_BAD_FRAME_VALUE(1'b1),
     .USER_BAD_FRAME_MASK(1'b1),
     .DROP_OVERSIZE_FRAME(RX_DROP_OVERSIZE_FRAME),
     .DROP_BAD_FRAME(RX_DROP_BAD_FRAME),
-    .DROP_WHEN_FULL(RX_DROP_WHEN_FULL)
+    .DROP_WHEN_FULL(RX_DROP_WHEN_FULL),
+    .upstream_async_fifo_p(0)
 )
 rx_fifo (
     // AXI input
     .s_clk(rx_clk),
     .s_rst(rx_rst),
     .s_axis_tdata(rx_fifo_axis_tdata),
-    .s_axis_tkeep(0),
+    .s_axis_tkeep(1'b0),
     .s_axis_tvalid(rx_fifo_axis_tvalid),
     .s_axis_tready(),
     .s_axis_tlast(rx_fifo_axis_tlast),
-    .s_axis_tid(0),
-    .s_axis_tdest(0),
+    .s_axis_tid(8'b0),
+    .s_axis_tdest(8'b0),
     .s_axis_tuser(rx_fifo_axis_tuser),
     // AXI output
     .m_clk(logic_clk),
@@ -354,5 +396,3 @@ rx_fifo (
 );
 
 endmodule
-
-`resetall
diff --git a/rtl/lfsr.v b/rtl/lfsr.v
index e3a472e..d7662b6 100644
--- a/rtl/lfsr.v
+++ b/rtl/lfsr.v
@@ -1,32 +1,4 @@
-/*
-
-Copyright (c) 2016-2023 Alex Forencich
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-*/
-
-// Language: Verilog 2001
-
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
+/*** This file is auto-generated from lfsr_template.v ***/
 
 /*
  * Parametrizable combinatorial parallel LFSR/CRC
@@ -54,295 +26,118 @@ module lfsr #
     output wire [DATA_WIDTH-1:0] data_out,
     output wire [LFSR_WIDTH-1:0] state_out
 );
-
-/*
-
-Fully parametrizable combinatorial parallel LFSR/CRC module.  Implements an unrolled LFSR
-next state computation, shifting DATA_WIDTH bits per pass through the module.  Input data
-is XORed with LFSR feedback path, tie data_in to zero if this is not required.
-
-Works in two parts: statically computes a set of bit masks, then uses these bit masks to
-select bits for XORing to compute the next state.  
-
-Ports:
-
-data_in
-
-Data bits to be shifted through the LFSR (DATA_WIDTH bits)
-
-state_in
-
-LFSR/CRC current state input (LFSR_WIDTH bits)
-
-data_out
-
-Data bits shifted out of LFSR (DATA_WIDTH bits)
-
-state_out
-
-LFSR/CRC next state output (LFSR_WIDTH bits)
-
-Parameters:
-
-LFSR_WIDTH
-
-Specify width of LFSR/CRC register
-
-LFSR_POLY
-
-Specify the LFSR/CRC polynomial in hex format.  For example, the polynomial
-
-x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1
-
-would be represented as
-
-32'h04c11db7
-
-Note that the largest term (x^32) is suppressed.  This term is generated automatically based
-on LFSR_WIDTH.
-
-LFSR_CONFIG
-
-Specify the LFSR configuration, either Fibonacci or Galois.  Fibonacci is generally used
-for linear-feedback shift registers (LFSR) for pseudorandom binary sequence (PRBS) generators,
-scramblers, and descrambers, while Galois is generally used for cyclic redundancy check
-generators and checkers.
-
-Fibonacci style (example for 64b66b scrambler, 0x8000000001)
-
-   DIN (LSB first)
-    |
-    V
-   (+)<---------------------------(+)<-----------------------------.
-    |                              ^                               |
-    |  .----.  .----.       .----. |  .----.       .----.  .----.  |
-    +->|  0 |->|  1 |->...->| 38 |-+->| 39 |->...->| 56 |->| 57 |--'
-    |  '----'  '----'       '----'    '----'       '----'  '----'
-    V
-   DOUT
-
-Galois style (example for CRC16, 0x8005)
-
-    ,-------------------+-------------------------+----------(+)<-- DIN (MSB first)
-    |                   |                         |           ^
-    |  .----.  .----.   V   .----.       .----.   V   .----.  |
-    `->|  0 |->|  1 |->(+)->|  2 |->...->| 14 |->(+)->| 15 |--+---> DOUT
-       '----'  '----'       '----'       '----'       '----'
-
-LFSR_FEED_FORWARD
-
-Generate feed forward instead of feed back LFSR.  Enable this for PRBS checking and self-
-synchronous descrambling.
-
-Fibonacci feed-forward style (example for 64b66b descrambler, 0x8000000001)
-
-   DIN (LSB first)
-    |
-    |  .----.  .----.       .----.    .----.       .----.  .----.
-    +->|  0 |->|  1 |->...->| 38 |-+->| 39 |->...->| 56 |->| 57 |--.
-    |  '----'  '----'       '----' |  '----'       '----'  '----'  |
-    |                              V                               |
-   (+)<---------------------------(+)------------------------------'
-    |
-    V
-   DOUT
-
-Galois feed-forward style
-
-    ,-------------------+-------------------------+------------+--- DIN (MSB first)
-    |                   |                         |            |
-    |  .----.  .----.   V   .----.       .----.   V   .----.   V
-    `->|  0 |->|  1 |->(+)->|  2 |->...->| 14 |->(+)->| 15 |->(+)-> DOUT
-       '----'  '----'       '----'       '----'       '----'
-
-REVERSE
-
-Bit-reverse LFSR input and output.  Shifts MSB first by default, set REVERSE for LSB first.
-
-DATA_WIDTH
-
-Specify width of input and output data bus.  The module will perform one shift per input
-data bit, so if the input data bus is not required tie data_in to zero and set DATA_WIDTH
-to the required number of shifts per clock cycle.  
-
-STYLE
-
-Specify implementation style.  Can be "AUTO", "LOOP", or "REDUCTION".  When "AUTO"
-is selected, implemenation will be "LOOP" or "REDUCTION" based on synthesis translate
-directives.  "REDUCTION" and "LOOP" are functionally identical, however they simulate
-and synthesize differently.  "REDUCTION" is implemented with a loop over a Verilog
-reduction operator.  "LOOP" is implemented as a doubly-nested loop with no reduction
-operator.  "REDUCTION" is very fast for simulation in iverilog and synthesizes well in
-Quartus but synthesizes poorly in ISE, likely due to large inferred XOR gates causing
-problems with the optimizer.  "LOOP" synthesizes will in both ISE and Quartus.  "AUTO"
-will default to "REDUCTION" when simulating and "LOOP" for synthesizers that obey
-synthesis translate directives.
-
-Settings for common LFSR/CRC implementations:
-
-Name        Configuration           Length  Polynomial      Initial value   Notes
-CRC16-IBM   Galois, bit-reverse     16      16'h8005        16'hffff
-CRC16-CCITT Galois                  16      16'h1021        16'h1d0f
-CRC32       Galois, bit-reverse     32      32'h04c11db7    32'hffffffff    Ethernet FCS; invert final output
-CRC32C      Galois, bit-reverse     32      32'h1edc6f41    32'hffffffff    iSCSI, Intel CRC32 instruction; invert final output
-PRBS6       Fibonacci               6       6'h21           any
-PRBS7       Fibonacci               7       7'h41           any
-PRBS9       Fibonacci               9       9'h021          any             ITU V.52
-PRBS10      Fibonacci               10      10'h081         any             ITU
-PRBS11      Fibonacci               11      11'h201         any             ITU O.152
-PRBS15      Fibonacci, inverted     15      15'h4001        any             ITU O.152
-PRBS17      Fibonacci               17      17'h04001       any
-PRBS20      Fibonacci               20      20'h00009       any             ITU V.57
-PRBS23      Fibonacci, inverted     23      23'h040001      any             ITU O.151
-PRBS29      Fibonacci, inverted     29      29'h08000001    any
-PRBS31      Fibonacci, inverted     31      31'h10000001    any
-64b66b      Fibonacci, bit-reverse  58      58'h8000000001  any             10G Ethernet
-128b130b    Galois, bit-reverse     23      23'h210125      any             PCIe gen 3
-
-*/
-
-function [LFSR_WIDTH+DATA_WIDTH-1:0] lfsr_mask(input [31:0] index);
-    reg [LFSR_WIDTH-1:0] lfsr_mask_state[LFSR_WIDTH-1:0];
-    reg [DATA_WIDTH-1:0] lfsr_mask_data[LFSR_WIDTH-1:0];
-    reg [LFSR_WIDTH-1:0] output_mask_state[DATA_WIDTH-1:0];
-    reg [DATA_WIDTH-1:0] output_mask_data[DATA_WIDTH-1:0];
-
-    reg [LFSR_WIDTH-1:0] state_val;
-    reg [DATA_WIDTH-1:0] data_val;
-
-    reg [DATA_WIDTH-1:0] data_mask;
-
-    integer i, j;
-
-    begin
-        // init bit masks
-        for (i = 0; i < LFSR_WIDTH; i = i + 1) begin
-            lfsr_mask_state[i] = 0;
-            lfsr_mask_state[i][i] = 1'b1;
-            lfsr_mask_data[i] = 0;
-        end
-        for (i = 0; i < DATA_WIDTH; i = i + 1) begin
-            output_mask_state[i] = 0;
-            if (i < LFSR_WIDTH) begin
-                output_mask_state[i][i] = 1'b1;
-            end
-            output_mask_data[i] = 0;
-        end
-
-        // simulate shift register
-        if (LFSR_CONFIG == "FIBONACCI") begin
-            // Fibonacci configuration
-            for (data_mask = {1'b1, {DATA_WIDTH-1{1'b0}}}; data_mask != 0; data_mask = data_mask >> 1) begin
-                // determine shift in value
-                // current value in last FF, XOR with input data bit (MSB first)
-                state_val = lfsr_mask_state[LFSR_WIDTH-1];
-                data_val = lfsr_mask_data[LFSR_WIDTH-1];
-                data_val = data_val ^ data_mask;
-
-                // add XOR inputs from correct indicies
-                for (j = 1; j < LFSR_WIDTH; j = j + 1) begin
-                    if ((LFSR_POLY >> j) & 1) begin
-                        state_val = lfsr_mask_state[j-1] ^ state_val;
-                        data_val = lfsr_mask_data[j-1] ^ data_val;
-                    end
-                end
-
-                // shift
-                for (j = LFSR_WIDTH-1; j > 0; j = j - 1) begin
-                    lfsr_mask_state[j] = lfsr_mask_state[j-1];
-                    lfsr_mask_data[j] = lfsr_mask_data[j-1];
-                end
-                for (j = DATA_WIDTH-1; j > 0; j = j - 1) begin
-                    output_mask_state[j] = output_mask_state[j-1];
-                    output_mask_data[j] = output_mask_data[j-1];
-                end
-                output_mask_state[0] = state_val;
-                output_mask_data[0] = data_val;
-                if (LFSR_FEED_FORWARD) begin
-                    // only shift in new input data
-                    state_val = {LFSR_WIDTH{1'b0}};
-                    data_val = data_mask;
-                end
-                lfsr_mask_state[0] = state_val;
-                lfsr_mask_data[0] = data_val;
-            end
-        end else if (LFSR_CONFIG == "GALOIS") begin
-            // Galois configuration
-            for (data_mask = {1'b1, {DATA_WIDTH-1{1'b0}}}; data_mask != 0; data_mask = data_mask >> 1) begin
-                // determine shift in value
-                // current value in last FF, XOR with input data bit (MSB first)
-                state_val = lfsr_mask_state[LFSR_WIDTH-1];
-                data_val = lfsr_mask_data[LFSR_WIDTH-1];
-                data_val = data_val ^ data_mask;
-
-                // shift
-                for (j = LFSR_WIDTH-1; j > 0; j = j - 1) begin
-                    lfsr_mask_state[j] = lfsr_mask_state[j-1];
-                    lfsr_mask_data[j] = lfsr_mask_data[j-1];
-                end
-                for (j = DATA_WIDTH-1; j > 0; j = j - 1) begin
-                    output_mask_state[j] = output_mask_state[j-1];
-                    output_mask_data[j] = output_mask_data[j-1];
-                end
-                output_mask_state[0] = state_val;
-                output_mask_data[0] = data_val;
-                if (LFSR_FEED_FORWARD) begin
-                    // only shift in new input data
-                    state_val = {LFSR_WIDTH{1'b0}};
-                    data_val = data_mask;
-                end
-                lfsr_mask_state[0] = state_val;
-                lfsr_mask_data[0] = data_val;
-
-                // add XOR inputs at correct indicies
-                for (j = 1; j < LFSR_WIDTH; j = j + 1) begin
-                    if ((LFSR_POLY >> j) & 1) begin
-                        lfsr_mask_state[j] = lfsr_mask_state[j] ^ state_val;
-                        lfsr_mask_data[j] = lfsr_mask_data[j] ^ data_val;
-                    end
-                end
-            end
-        end else begin
-            $error("Error: unknown configuration setting!");
-            $finish;
-        end
-
-        // reverse bits if selected
-        if (REVERSE) begin
-            if (index < LFSR_WIDTH) begin
-                state_val = 0;
-                for (i = 0; i < LFSR_WIDTH; i = i + 1) begin
-                    state_val[i] = lfsr_mask_state[LFSR_WIDTH-index-1][LFSR_WIDTH-i-1];
-                end
-
-                data_val = 0;
-                for (i = 0; i < DATA_WIDTH; i = i + 1) begin
-                    data_val[i] = lfsr_mask_data[LFSR_WIDTH-index-1][DATA_WIDTH-i-1];
-                end
-            end else begin
-                state_val = 0;
-                for (i = 0; i < LFSR_WIDTH; i = i + 1) begin
-                    state_val[i] = output_mask_state[DATA_WIDTH-(index-LFSR_WIDTH)-1][LFSR_WIDTH-i-1];
-                end
-
-                data_val = 0;
-                for (i = 0; i < DATA_WIDTH; i = i + 1) begin
-                    data_val[i] = output_mask_data[DATA_WIDTH-(index-LFSR_WIDTH)-1][DATA_WIDTH-i-1];
-                end
-            end
-        end else begin
-            if (index < LFSR_WIDTH) begin
-                state_val = lfsr_mask_state[index];
-                data_val = lfsr_mask_data[index];
-            end else begin
-                state_val = output_mask_state[index-LFSR_WIDTH];
-                data_val = output_mask_data[index-LFSR_WIDTH];
-            end
-        end
-        lfsr_mask = {data_val, state_val};
+/* === Settings ===
+ * LFSR_WIDTH: 32
+ * LFSR_POLY: 0x04c11db7
+ * LFSR_CONFIG: "GALOIS"
+ * LFSR_FEED_FORWARD: 0
+ * REVERSE: 1
+ * DATA_WIDTH: 8
+ */
+initial begin
+    if(LFSR_WIDTH != 32 ||
+        LFSR_POLY != 32'h04c11db7 ||
+        LFSR_CONFIG != "GALOIS" ||
+        LFSR_FEED_FORWARD != 0 ||
+        REVERSE != 1 ||
+        DATA_WIDTH != 8) begin
+        $error("Error: unsupported lfsr settings");
+        $finish;
     end
-endfunction
-
+end
+wire [31:0][31:0] lfsr_mask_state = {
+32'b00000000000000000000000010000010,
+32'b00000000000000000000000011000011,
+32'b00000000000000000000000011100011,
+32'b00000000000000000000000001110001,
+32'b00000000000000000000000010111010,
+32'b00000000000000000000000011011111,
+32'b00000000000000000000000001101111,
+32'b00000000000000000000000010110101,
+32'b10000000000000000000000011011000,
+32'b01000000000000000000000001101100,
+32'b00100000000000000000000010110100,
+32'b00010000000000000000000011011000,
+32'b00001000000000000000000011101110,
+32'b00000100000000000000000001110111,
+32'b00000010000000000000000000111011,
+32'b00000001000000000000000000011101,
+32'b00000000100000000000000010001100,
+32'b00000000010000000000000001000110,
+32'b00000000001000000000000000100011,
+32'b00000000000100000000000000010001,
+32'b00000000000010000000000000001000,
+32'b00000000000001000000000000000100,
+32'b00000000000000100000000010000000,
+32'b00000000000000010000000011000010,
+32'b00000000000000001000000001100001,
+32'b00000000000000000100000000110000,
+32'b00000000000000000010000010011010,
+32'b00000000000000000001000001001101,
+32'b00000000000000000000100000100110,
+32'b00000000000000000000010000010011,
+32'b00000000000000000000001000001001,
+32'b00000000000000000000000100000100
+};
+
+wire [31:0][7:0] lfsr_mask_data = {
+8'b10000010,
+8'b11000011,
+8'b11100011,
+8'b01110001,
+8'b10111010,
+8'b11011111,
+8'b01101111,
+8'b10110101,
+8'b11011000,
+8'b01101100,
+8'b10110100,
+8'b11011000,
+8'b11101110,
+8'b01110111,
+8'b00111011,
+8'b00011101,
+8'b10001100,
+8'b01000110,
+8'b00100011,
+8'b00010001,
+8'b00001000,
+8'b00000100,
+8'b10000000,
+8'b11000010,
+8'b01100001,
+8'b00110000,
+8'b10011010,
+8'b01001101,
+8'b00100110,
+8'b00010011,
+8'b00001001,
+8'b00000100
+};
+
+wire [7:0][31:0] output_mask_state = {
+32'b00000000000000000000000010000010,
+32'b00000000000000000000000001000001,
+32'b00000000000000000000000000100000,
+32'b00000000000000000000000000010000,
+32'b00000000000000000000000000001000,
+32'b00000000000000000000000000000100,
+32'b00000000000000000000000000000010,
+32'b00000000000000000000000000000001
+};
+
+wire [7:0][7:0] output_mask_data = {
+8'b10000010,
+8'b01000001,
+8'b00100000,
+8'b00010000,
+8'b00001000,
+8'b00000100,
+8'b00000010,
+8'b00000001
+};
+
+integer i, j, k;
 // synthesis translate_off
 `define SIMULATION
 // synthesis translate_on
@@ -367,13 +162,11 @@ if (STYLE_INT == "REDUCTION") begin
     // slightly smaller than generated code with Quartus
     // --> better for simulation
 
-    for (n = 0; n < LFSR_WIDTH; n = n + 1) begin : lfsr_state
-        wire [LFSR_WIDTH+DATA_WIDTH-1:0] mask = lfsr_mask(n);
-        assign state_out[n] = ^({data_in, state_in} & mask);
+    for (n = 0; n < LFSR_WIDTH; n = n + 1) begin : loop1
+        assign state_out[n] = ^{(state_in & lfsr_mask_state[n]), (data_in & lfsr_mask_data[n])};
     end
-    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : lfsr_data
-        wire [LFSR_WIDTH+DATA_WIDTH-1:0] mask = lfsr_mask(n+LFSR_WIDTH);
-        assign data_out[n] = ^({data_in, state_in} & mask);
+    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : loop2
+        assign data_out[n] = ^{(state_in & output_mask_state[n]), (data_in & output_mask_data[n])};
     end
 
 end else if (STYLE_INT == "LOOP") begin
@@ -384,48 +177,36 @@ end else if (STYLE_INT == "LOOP") begin
     // same size as generated code with Quartus
     // --> better for synthesis
 
-    for (n = 0; n < LFSR_WIDTH; n = n + 1) begin : lfsr_state
-        wire [LFSR_WIDTH+DATA_WIDTH-1:0] mask = lfsr_mask(n);
-
-        reg state_reg;
+    reg [LFSR_WIDTH-1:0] state_out_reg;
+    reg [DATA_WIDTH-1:0] data_out_reg;
 
-        assign state_out[n] = state_reg;
+    assign state_out = state_out_reg;
+    assign data_out = data_out_reg;
 
-        integer i;
-
-        always @* begin
-            state_reg = 1'b0;
-            for (i = 0; i < LFSR_WIDTH; i = i + 1) begin
-                if (mask[i]) begin
-                    state_reg = state_reg ^ state_in[i];
+    always @* begin
+        for (i = 0; i < LFSR_WIDTH; i = i + 1) begin
+            state_out_reg[i] = 0;
+            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin
+                if (lfsr_mask_state[i][j]) begin
+                    state_out_reg[i] = state_out_reg[i] ^ state_in[j];
                 end
             end
-            for (i = 0; i < DATA_WIDTH; i = i + 1) begin
-                if (mask[i+LFSR_WIDTH]) begin
-                    state_reg = state_reg ^ data_in[i];
+            for (j = 0; j < DATA_WIDTH; j = j + 1) begin
+                if (lfsr_mask_data[i][j]) begin
+                    state_out_reg[i] = state_out_reg[i] ^ data_in[j];
                 end
             end
         end
-    end
-    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : lfsr_data
-        wire [LFSR_WIDTH+DATA_WIDTH-1:0] mask = lfsr_mask(n+LFSR_WIDTH);
-
-        reg data_reg;
-
-        assign data_out[n] = data_reg;
-
-        integer i;
-
-        always @* begin
-            data_reg = 1'b0;
-            for (i = 0; i < LFSR_WIDTH; i = i + 1) begin
-                if (mask[i]) begin
-                    data_reg = data_reg ^ state_in[i];
+        for (i = 0; i < DATA_WIDTH; i = i + 1) begin
+            data_out_reg[i] = 0;
+            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin
+                if (output_mask_state[i][j]) begin
+                    data_out_reg[i] = data_out_reg[i] ^ state_in[j];
                 end
             end
-            for (i = 0; i < DATA_WIDTH; i = i + 1) begin
-                if (mask[i+LFSR_WIDTH]) begin
-                    data_reg = data_reg ^ data_in[i];
+            for (j = 0; j < DATA_WIDTH; j = j + 1) begin
+                if (output_mask_data[i][j]) begin
+                    data_out_reg[i] = data_out_reg[i] ^ data_in[j];
                 end
             end
         end
@@ -443,5 +224,3 @@ end
 endgenerate
 
 endmodule
-
-`resetall
diff --git a/rtl/rgmii_phy_if.v b/rtl/rgmii_phy_if.v
index ed50581..2e80873 100644
--- a/rtl/rgmii_phy_if.v
+++ b/rtl/rgmii_phy_if.v
@@ -24,43 +24,64 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
+/*************************************************************************************
+
+clk250_i:
+    +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +-
+        |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
+        +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
+
+
+clk250_rst_i:
+    +--------+
+             |
+             +-----------------------------------------------------------------------+
+
+
+phy_rgmii_tx_clk:
+                                                 +-------+       +-------+       +---+
+                                                 |       |       |       |       |
+    +--------------------------------------------+       +-------+       +-------+
+
+
+mac_gmii_tx_clk:
+                     +-------+       +-------+       +-------+       +-------+
+                     |       |       |       |       |       |       |       |
+    +----------------+       +-------+       +-------+       +-------+       +-------+
+
+
+gmii_txd, gmii_tx_en, gmii_tx_er:
+    +---------------------------------+---------------+---------------+--------------+
+                                      |      d1d0     |      d1d0     |      d1d0
+    +---------------------------------+---------------+---------------+--------------+
+
+
+rgmii_txd, rgmii_tx_ctl:
+    +--------------------------------------------------------+-------+-------+-------+
+                                                             |  d0   |  d1   |  d0   |
+    +--------------------------------------------------------+-------+-------+-------+
+
+*************************************************************************************/
+
 
 /*
  * RGMII PHY interface
  */
-module rgmii_phy_if #
-(
-    // target ("SIM", "GENERIC", "XILINX", "ALTERA")
-    parameter TARGET = "GENERIC",
-    // IODDR style ("IODDR", "IODDR2")
-    // Use IODDR for Virtex-4, Virtex-5, Virtex-6, 7 Series, Ultrascale
-    // Use IODDR2 for Spartan-6
-    parameter IODDR_STYLE = "IODDR2",
-    // Clock input style ("BUFG", "BUFR", "BUFIO", "BUFIO2")
-    // Use BUFR for Virtex-6, 7-series
-    // Use BUFG for Virtex-5, Spartan-6, Ultrascale
-    parameter CLOCK_INPUT_STYLE = "BUFG",
-    // Use 90 degree clock for RGMII transmit ("TRUE", "FALSE")
-    parameter USE_CLK90 = "TRUE"
-)
-(
-    input  wire        clk,
-    input  wire        clk90,
-    input  wire        rst,
+module rgmii_phy_if (
+    input  wire        clk250,
+    input  wire        clk250_rst,
+    input  wire        tx_clk_gen_rst,
 
     /*
      * GMII interface to MAC
      */
     output wire        mac_gmii_rx_clk,
-    output wire        mac_gmii_rx_rst,
+    input  wire        mac_gmii_rx_rst,
     output wire [7:0]  mac_gmii_rxd,
     output wire        mac_gmii_rx_dv,
     output wire        mac_gmii_rx_er,
     output wire        mac_gmii_tx_clk,
-    output wire        mac_gmii_tx_rst,
+    input  wire        mac_gmii_tx_rst,
     output wire        mac_gmii_tx_clk_en,
     input  wire [7:0]  mac_gmii_txd,
     input  wire        mac_gmii_tx_en,
@@ -89,9 +110,6 @@ wire rgmii_rx_ctl_2;
 
 ssio_ddr_in #
 (
-    .TARGET(TARGET),
-    .CLOCK_INPUT_STYLE(CLOCK_INPUT_STYLE),
-    .IODDR_STYLE(IODDR_STYLE),
     .WIDTH(5)
 )
 rx_ssio_ddr_inst (
@@ -107,86 +125,94 @@ assign mac_gmii_rx_er = rgmii_rx_ctl_1 ^ rgmii_rx_ctl_2;
 
 // transmit
 
-reg rgmii_tx_clk_1 = 1'b1;
-reg rgmii_tx_clk_2 = 1'b0;
-reg rgmii_tx_clk_en = 1'b1;
-
-reg [5:0] count_reg = 6'd0, count_next;
+reg rgmii_tx_clk_1;
+reg rgmii_tx_clk_2;
+reg rgmii_tx_clk_rise;
+reg rgmii_tx_clk_fall;
 
-always @(posedge clk) begin
-    rgmii_tx_clk_1 <= rgmii_tx_clk_2;
-
-    if (speed == 2'b00) begin
-        // 10M
-        count_reg <= count_reg + 1;
-        rgmii_tx_clk_en <= 1'b0;
-        if (count_reg == 24) begin
-            rgmii_tx_clk_1 <= 1'b1;
-            rgmii_tx_clk_2 <= 1'b1;
-        end else if (count_reg >= 49) begin
-            rgmii_tx_clk_2 <= 1'b0;
-            rgmii_tx_clk_en <= 1'b1;
-            count_reg <= 0;
-        end
-    end else if (speed == 2'b01) begin
-        // 100M
-        count_reg <= count_reg + 1;
-        rgmii_tx_clk_en <= 1'b0;
-        if (count_reg == 2) begin
-            rgmii_tx_clk_1 <= 1'b1;
-            rgmii_tx_clk_2 <= 1'b1;
-        end else if (count_reg >= 4) begin
-            rgmii_tx_clk_2 <= 1'b0;
-            rgmii_tx_clk_en <= 1'b1;
-            count_reg <= 0;
-        end
-    end else begin
-        // 1000M
-        rgmii_tx_clk_1 <= 1'b1;
-        rgmii_tx_clk_2 <= 1'b0;
-        rgmii_tx_clk_en <= 1'b1;
-    end
+reg [5:0] count_reg;
 
-    if (rst) begin
+always @(posedge mac_gmii_tx_clk) begin
+    if (mac_gmii_tx_rst) begin
         rgmii_tx_clk_1 <= 1'b1;
         rgmii_tx_clk_2 <= 1'b0;
-        rgmii_tx_clk_en <= 1'b1;
+        rgmii_tx_clk_rise <= 1'b1;
+        rgmii_tx_clk_fall <= 1'b1;
         count_reg <= 0;
+    end else begin
+        rgmii_tx_clk_1 <= rgmii_tx_clk_2;
+
+        if (speed == 2'b00) begin
+            // 10M
+            count_reg <= count_reg + 1;
+            rgmii_tx_clk_rise <= 1'b0;
+            rgmii_tx_clk_fall <= 1'b0;
+            if (count_reg == 24) begin
+                rgmii_tx_clk_1 <= 1'b1;
+                rgmii_tx_clk_2 <= 1'b1;
+                rgmii_tx_clk_rise <= 1'b1;
+            end else if (count_reg >= 49) begin
+                rgmii_tx_clk_1 <= 1'b0;
+                rgmii_tx_clk_2 <= 1'b0;
+                rgmii_tx_clk_fall <= 1'b1;
+                count_reg <= 0;
+            end
+        end else if (speed == 2'b01) begin
+            // 100M
+            count_reg <= count_reg + 1;
+            rgmii_tx_clk_rise <= 1'b0;
+            rgmii_tx_clk_fall <= 1'b0;
+            if (count_reg == 2) begin
+                rgmii_tx_clk_1 <= 1'b1;
+                rgmii_tx_clk_2 <= 1'b1;
+                rgmii_tx_clk_rise <= 1'b1;
+            end else if (count_reg >= 4) begin
+                rgmii_tx_clk_2 <= 1'b0;
+                rgmii_tx_clk_fall <= 1'b1;
+                count_reg <= 0;
+            end
+        end else begin
+            // 1000M
+            rgmii_tx_clk_1 <= 1'b1;
+            rgmii_tx_clk_2 <= 1'b0;
+            rgmii_tx_clk_rise <= 1'b1;
+            rgmii_tx_clk_fall <= 1'b1;
+        end
     end
 end
 
-reg [3:0] rgmii_txd_1 = 0;
-reg [3:0] rgmii_txd_2 = 0;
-reg rgmii_tx_ctl_1 = 1'b0;
-reg rgmii_tx_ctl_2 = 1'b0;
+reg [3:0] rgmii_txd_1;
+reg [3:0] rgmii_txd_2;
+reg rgmii_tx_ctl_1;
+reg rgmii_tx_ctl_2;
 
-reg gmii_clk_en = 1'b1;
+reg gmii_clk_en;
 
 always @* begin
     if (speed == 2'b00) begin
         // 10M
         rgmii_txd_1 = mac_gmii_txd[3:0];
         rgmii_txd_2 = mac_gmii_txd[3:0];
-        if (rgmii_tx_clk_1) begin
-            rgmii_tx_ctl_1 = mac_gmii_tx_en ^ mac_gmii_tx_er;
-            rgmii_tx_ctl_2 = mac_gmii_tx_en ^ mac_gmii_tx_er;
-        end else begin
+        if (rgmii_tx_clk_2) begin
             rgmii_tx_ctl_1 = mac_gmii_tx_en;
             rgmii_tx_ctl_2 = mac_gmii_tx_en;
+        end else begin
+            rgmii_tx_ctl_1 = mac_gmii_tx_en ^ mac_gmii_tx_er;
+            rgmii_tx_ctl_2 = mac_gmii_tx_en ^ mac_gmii_tx_er;
         end
-        gmii_clk_en = rgmii_tx_clk_en;
+        gmii_clk_en = rgmii_tx_clk_fall;
     end else if (speed == 2'b01) begin
         // 100M
         rgmii_txd_1 = mac_gmii_txd[3:0];
         rgmii_txd_2 = mac_gmii_txd[3:0];
-        if (rgmii_tx_clk_1) begin
-            rgmii_tx_ctl_1 = mac_gmii_tx_en ^ mac_gmii_tx_er;
-            rgmii_tx_ctl_2 = mac_gmii_tx_en ^ mac_gmii_tx_er;
-        end else begin
+        if (rgmii_tx_clk_2) begin
             rgmii_tx_ctl_1 = mac_gmii_tx_en;
             rgmii_tx_ctl_2 = mac_gmii_tx_en;
+        end else begin
+            rgmii_tx_ctl_1 = mac_gmii_tx_en ^ mac_gmii_tx_er;
+            rgmii_tx_ctl_2 = mac_gmii_tx_en ^ mac_gmii_tx_er;
         end
-        gmii_clk_en = rgmii_tx_clk_en;
+        gmii_clk_en = rgmii_tx_clk_fall;
     end else begin
         // 1000M
         rgmii_txd_1 = mac_gmii_txd[3:0];
@@ -197,61 +223,27 @@ always @* begin
     end
 end
 
-wire phy_rgmii_tx_clk_new;
-wire [3:0] phy_rgmii_txd_new;
-wire phy_rgmii_tx_ctl_new;
+tx_clks_generator
+ tx_clks_gen
+  (.clk250_i(clk250)
+   ,.clk250_rst_i(clk250_rst)
+   ,.tx_clk_gen_rst_i(tx_clk_gen_rst)
 
-oddr #(
-    .TARGET(TARGET),
-    .IODDR_STYLE(IODDR_STYLE),
-    .WIDTH(1)
-)
-clk_oddr_inst (
-    .clk(USE_CLK90 == "TRUE" ? clk90 : clk),
-    .d1(rgmii_tx_clk_1),
-    .d2(rgmii_tx_clk_2),
-    .q(phy_rgmii_tx_clk)
-);
+   ,.phy_rgmii_tx_clk_setting_i({rgmii_tx_clk_2, rgmii_tx_clk_1})
+   ,.phy_rgmii_tx_clk_o(phy_rgmii_tx_clk)
+   ,.mac_gmii_tx_clk_o(mac_gmii_tx_clk));
 
-oddr #(
-    .TARGET(TARGET),
-    .IODDR_STYLE(IODDR_STYLE),
-    .WIDTH(5)
-)
-data_oddr_inst (
-    .clk(clk),
-    .d1({rgmii_txd_1, rgmii_tx_ctl_1}),
-    .d2({rgmii_txd_2, rgmii_tx_ctl_2}),
-    .q({phy_rgmii_txd, phy_rgmii_tx_ctl})
-);
+bsg_link_oddr_phy #(.width_p(5))
+ data_oddr_inst
+  (.reset_i(clk250_rst)
+   ,.clk_i(clk250)
+   ,.data_i({{rgmii_txd_2, rgmii_tx_ctl_2}, {rgmii_txd_1, rgmii_tx_ctl_1}})
+   ,.ready_o(/* UNUSED */)
 
-assign mac_gmii_tx_clk = clk;
+   ,.data_r_o({phy_rgmii_txd, phy_rgmii_tx_ctl})
+   ,.clk_r_o(/* UNUSED */)
+  );
 
 assign mac_gmii_tx_clk_en = gmii_clk_en;
 
-// reset sync
-reg [3:0] tx_rst_reg = 4'hf;
-assign mac_gmii_tx_rst = tx_rst_reg[0];
-
-always @(posedge mac_gmii_tx_clk or posedge rst) begin
-    if (rst) begin
-        tx_rst_reg <= 4'hf;
-    end else begin
-        tx_rst_reg <= {1'b0, tx_rst_reg[3:1]};
-    end
-end
-
-reg [3:0] rx_rst_reg = 4'hf;
-assign mac_gmii_rx_rst = rx_rst_reg[0];
-
-always @(posedge mac_gmii_rx_clk or posedge rst) begin
-    if (rst) begin
-        rx_rst_reg <= 4'hf;
-    end else begin
-        rx_rst_reg <= {1'b0, rx_rst_reg[3:1]};
-    end
-end
-
 endmodule
-
-`resetall
diff --git a/rtl/ssio_ddr_in.v b/rtl/ssio_ddr_in.v
index 1dd1840..683ff12 100644
--- a/rtl/ssio_ddr_in.v
+++ b/rtl/ssio_ddr_in.v
@@ -24,25 +24,11 @@ THE SOFTWARE.
 
 // Language: Verilog 2001
 
-`resetall
-`timescale 1ns / 1ps
-`default_nettype none
-
 /*
  * Generic source synchronous DDR input
  */
 module ssio_ddr_in #
 (
-    // target ("SIM", "GENERIC", "XILINX", "ALTERA")
-    parameter TARGET = "GENERIC",
-    // IODDR style ("IODDR", "IODDR2")
-    // Use IODDR for Virtex-4, Virtex-5, Virtex-6, 7 Series, Ultrascale
-    // Use IODDR2 for Spartan-6
-    parameter IODDR_STYLE = "IODDR2",
-    // Clock input style ("BUFG", "BUFR", "BUFIO", "BUFIO2")
-    // Use BUFR for Virtex-6, 7-series
-    // Use BUFG for Virtex-5, Spartan-6, Ultrascale
-    parameter CLOCK_INPUT_STYLE = "BUFG",
     // Width of register in bits
     parameter WIDTH = 1
 )
@@ -57,95 +43,18 @@ module ssio_ddr_in #
     output wire [WIDTH-1:0] output_q2
 );
 
-wire clk_int;
-wire clk_io;
-
+genvar n;
 generate
-
-if (TARGET == "XILINX") begin
-
-    // use Xilinx clocking primitives
-
-    if (CLOCK_INPUT_STYLE == "BUFG") begin
-
-        // buffer RX clock
-        BUFG
-        clk_bufg (
-            .I(input_clk),
-            .O(clk_int)
-        );
-
-        // pass through RX clock to logic and input buffers
-        assign clk_io = clk_int;
-        assign output_clk = clk_int;
-
-    end else if (CLOCK_INPUT_STYLE == "BUFR") begin
-
-        assign clk_int = input_clk;
-
-        // pass through RX clock to input buffers
-        BUFIO
-        clk_bufio (
-            .I(clk_int),
-            .O(clk_io)
-        );
-
-        // pass through RX clock to logic
-        BUFR #(
-            .BUFR_DIVIDE("BYPASS")
-        )
-        clk_bufr (
-            .I(clk_int),
-            .O(output_clk),
-            .CE(1'b1),
-            .CLR(1'b0)
-        );
-        
-    end else if (CLOCK_INPUT_STYLE == "BUFIO") begin
-
-        assign clk_int = input_clk;
-
-        // pass through RX clock to input buffers
-        BUFIO
-        clk_bufio (
-            .I(clk_int),
-            .O(clk_io)
-        );
-
-        // pass through RX clock to MAC
-        BUFG
-        clk_bufg (
-            .I(clk_int),
-            .O(output_clk)
-        );
-
-    end
-
-end else begin
-
-    // pass through RX clock to input buffers
-    assign clk_io = input_clk;
-
-    // pass through RX clock to logic
-    assign clk_int = input_clk;
-    assign output_clk = clk_int;
-
+for (n = 0; n < WIDTH; n = n + 1) begin : iddr
+    bsg_link_iddr_phy #(.width_p(1))
+      iddr_inst (
+        .clk_i(input_clk)
+       ,.data_i(input_d[n])
+       ,.data_r_o({output_q2[n], output_q1[n]})
+      );
 end
-
 endgenerate
 
-iddr #(
-    .TARGET(TARGET),
-    .IODDR_STYLE(IODDR_STYLE),
-    .WIDTH(WIDTH)
-)
-data_iddr_inst (
-    .clk(clk_io),
-    .d(input_d),
-    .q1(output_q1),
-    .q2(output_q2)
-);
+assign output_clk = input_clk;
 
 endmodule
-
-`resetall
-- 
2.16.5

